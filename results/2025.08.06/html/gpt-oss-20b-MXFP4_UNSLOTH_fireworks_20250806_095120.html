<!DOCTYPE html>
<html>
<head>
    <title>Fireworks Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { border: 1px solid #444; background-color: #000; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="512" height="512"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        /* ---------- Utility helpers ---------- */
        function randomInRange(min, max) { return Math.random() * (max - min) + min; }
        function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

        /* ---------- Physics constants ---------- */
        const GRAVITY = H * 0.5;          // pixels / s²  (downward)
        const ROCKET_MIN_VY = -H * 1.0;   // initial upward speed
        const ROCKET_MAX_VY = -H * 0.8;
        const ROCKET_MIN_VX = -H * 0.1;   // small horizontal jitter
        const ROCKET_MAX_VX = H * 0.1;

        /* ---------- Particle classes ---------- */
        class Rocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = randomInRange(ROCKET_MIN_VX, ROCKET_MAX_VX);
                this.vy = randomInRange(ROCKET_MIN_VY, ROCKET_MAX_VY);
                this.hue = randomInt(0, 360);
                this.fuseTime = randomInRange(1.0, 2.0); // seconds until explosion
                this.elapsed = 0;
                this.exploded = false;
                this.type = 'rocket';
            }
            update(dt) {
                this.elapsed += dt;
                this.vy += GRAVITY * dt;          // gravity slows the ascent
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                if (this.elapsed > this.fuseTime) this.exploded = true;
            }
            draw(ctx) {
                ctx.fillStyle = `hsl(${this.hue},80%,60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class ExplosionParticle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = randomInRange(H * 0.1, H * 0.3); // outward speed
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = randomInRange(1.0, 3.0); // seconds
                this.remaining = this.life;
                this.size = randomInRange(1, 3);
                this.hue = hue;
                this.type = 'particle';
            }
            update(dt) {
                this.vy += GRAVITY * dt;      // gravity pulls particles down
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.remaining -= dt;
            }
            isAlive() { return this.remaining > 0; }
            draw(ctx) {
                const alpha = Math.max(this.remaining / this.life, 0);
                ctx.fillStyle = `hsla(${this.hue},80%,60%,${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /* ---------- Simulation state ---------- */
        const particles = [];          // holds both rockets & explosion fragments
        let lastLaunchTime = 0;
        let nextLaunchInterval = randomInRange(500, 2000); // ms

        /* ---------- Helper functions ---------- */
        function launchRocket() {
            const x = W / 2 + randomInRange(-W / 20, W / 20);
            const y = H + 5; // start just below the canvas
            particles.push(new Rocket(x, y));
        }

        function createExplosion(x, y, hue) {
            const count = randomInt(30, 80);
            for (let i = 0; i < count; i++) {
                particles.push(new ExplosionParticle(x, y, hue));
            }
        }

        /* ---------- Main loop ---------- */
        let lastTimestamp = performance.now();

        function gameLoop(timestamp) {
            const dt = (timestamp - lastTimestamp) / 1000; // delta time in seconds
            lastTimestamp = timestamp;

            /* --- Autonomous launch logic --- */
            if (timestamp - lastLaunchTime > nextLaunchInterval) {
                launchRocket();
                lastLaunchTime = timestamp;
                nextLaunchInterval = randomInRange(500, 2000);
            }

            /* --- Update particles --- */
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(dt);

                if (p.type === 'rocket' && p.exploded) {
                    createExplosion(p.x, p.y, p.hue);
                    particles.splice(i, 1); // remove exploded rocket
                } else if (p.type === 'particle' && !p.isAlive()) {
                    particles.splice(i, 1); // remove dead fragment
                }
            }

            /* --- Render --- */
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            for (const p of particles) p.draw(ctx);

            requestAnimationFrame(gameLoop);
        }

        // Kick off the simulation
        requestAnimationFrame(gameLoop);
    </script>
    <section id="notes">
        <h2>How the simulation works</h2>
        <p>
            <strong>Particle array</strong>: All rockets and explosion fragments are stored in a single <code>particles</code> array. Each element has a <code>type</code> field to distinguish rockets from fragments.
        </p>
        <p>
            <strong>Autonomous launching</strong>: A timer controls when a new rocket is spawned. The interval is random between 0.5 and 2 seconds.
        </p>
        <p>
            <strong>Rocket physics</strong>: Rockets start below the canvas with a strong upward velocity and a small horizontal jitter. Gravity is applied each frame, slowing them until they explode after a random fuse time (1–2 s).
        </p>
        <p>
            <strong>Explosion</strong>: When a rocket explodes, 30–80 fragments are created. Their velocities radiate outward randomly, and they fall under gravity while fading out over 1–3 s.
        </p>
        <p>
            <strong>Delta‑time</strong>: The <code>dt</code> value (in seconds) is derived from the timestamps supplied by <code>requestAnimationFrame</code>, ensuring smooth animation regardless of frame rate.
        </p>
        <p>
            <strong>Performance</strong>: Particles are removed from the array in a reverse loop to avoid shifting indices. Only a few dozen particles are alive at any moment, so the simulation runs smoothly even at high frame rates.
        </p>
    </section>
</body>
</html>