<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
        #notes {
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #e8f4fc;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            line-height: 1.5;
        }
        #notes h3 {
            margin-top: 0;
            color: #2c6eaa;
        }
        #notes ul {
            padding-left: 20px;
            margin-top: 10px;
        }
        #notes li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Physics constants
        const GRAVITY = 0.2;
        const DAMPING = 0.8;  // Energy loss factor for collisions
        const COEFFICIENT_OF_RESTITUTION = 0.8; // For ball-ball collisions
        const NUM_BALLS = 60;
        const GRID_COLS = 20;
        const GRID_ROWS = 15;

        // Ball class for encapsulation
        class Ball {
            constructor() {
                // Random position within canvas (avoiding edges)
                this.x = Math.random() * (W - 40) + 20;
                this.y = Math.random() * (H - 40) + 20;
                
                // Random velocity (moderate speed)
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                
                // Random radius (5-20 pixels)
                this.r = Math.random() * 15 + 5;
                
                // Mass proportional to area (radius squared)
                this.mass = this.r * this.r;
                
                // Random color
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }

            // Update position with gravity
            update() {
                this.vy += GRAVITY;
                this.x += this.vx;
                this.y += this.vy;
            }

            // Draw the ball
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Initialize all balls
        const balls = [];
        for (let i = 0; i < NUM_BALLS; i++) {
            balls.push(new Ball());
        }

        // Grid for spatial partitioning (optimization)
        const grid = Array(GRID_COLS).fill(null).map(() => 
            Array(GRID_ROWS).fill(null).map(() => [])
        );
        const cellWidth = W / GRID_COLS;
        const cellHeight = H / GRID_ROWS;

        // Clear grid for the current frame
        function clearGrid() {
            for (let x = 0; x < GRID_COLS; x++) {
                for (let y = 0; y < GRID_ROWS; y++) {
                    grid[x][y] = [];
                }
            }
        }

        // Add balls to grid based on current positions
        function addToGrid() {
            clearGrid();
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                const cellX = Math.floor(ball.x / cellWidth);
                const cellY = Math.floor(ball.y / cellHeight);
                
                if (cellX >= 0 && cellX < GRID_COLS && 
                    cellY >= 0 && cellY < GRID_ROWS) {
                    grid[cellX][cellY].push(i);
                }
            }
        }

        // Check collisions between balls using grid
        function checkBallCollisions() {
            for (let i = 0; i < balls.length; i++) {
                const ball1 = balls[i];
                const cellX = Math.floor(ball1.x / cellWidth);
                const cellY = Math.floor(ball1.y / cellHeight);
                
                // Check 3x3 neighborhood around the cell
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const nx = cellX + dx;
                        const ny = cellY + dy;
                        
                        if (nx >= 0 && nx < GRID_COLS && 
                            ny >= 0 && ny < GRID_ROWS) {
                            
                            for (const j of grid[nx][ny]) {
                                // Avoid self-collision and duplicate checks
                                if (j <= i) continue;
                                
                                const ball2 = balls[j];
                                const dx = ball2.x - ball1.x;
                                const dy = ball2.y - ball1.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const rSum = ball1.r + ball2.r;
                                
                                // Check if balls are colliding
                                if (dist < rSum) {
                                    // Calculate overlap and correct positions
                                    const overlap = (rSum - dist) * 0.5;
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    
                                    ball1.x -= overlap * nx;
                                    ball1.y -= overlap * ny;
                                    ball2.x += overlap * nx;
                                    ball2.y += overlap * ny;
                                    
                                    // Calculate normal component of velocities
                                    const v1n = ball1.vx * nx + ball1.vy * ny;
                                    const v2n = ball2.vx * nx + ball2.vy * ny;
                                    const vRel = v1n - v2n;
                                    
                                    // Only process if moving towards each other
                                    if (vRel < 0) {
                                        // Calculate impulse
                                        const j = (-(1 + COEFFICIENT_OF_RESTITUTION) * vRel) / 
                                                  (1 / ball1.mass + 1 / ball2.mass);
                                        
                                        // Apply impulse to both balls
                                        ball1.vx += j * nx / ball1.mass;
                                        ball1.vy += j * ny / ball1.mass;
                                        ball2.vx -= j * nx / ball2.mass;
                                        ball2.vy -= j * ny / ball2.mass;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Check and handle wall collisions
        function handleWallCollisions() {
            for (const ball of balls) {
                // Left wall
                if (ball.x - ball.r < 0) {
                    ball.x = ball.r;
                    ball.vx = -ball.vx * DAMPING;
                }
                // Right wall
                else if (ball.x + ball.r > W) {
                    ball.x = W - ball.r;
                    ball.vx = -ball.vx * DAMPING;
                }
                // Top wall
                if (ball.y - ball.r < 0) {
                    ball.y = ball.r;
                    ball.vy = -ball.vy * DAMPING;
                }
                // Bottom wall
                else if (ball.y + ball.r > H) {
                    ball.y = H - ball.r;
                    ball.vy = -ball.vy * DAMPING;
                }
            }
        }

        // Main animation loop
        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);
            
            // Update positions with gravity
            for (const ball of balls) {
                ball.update();
            }
            
            // Handle wall collisions
            handleWallCollisions();
            
            // Build grid for ball collision detection
            addToGrid();
            
            // Check ball-ball collisions
            checkBallCollisions();
            
            // Draw all balls
            for (const ball of balls) {
                ball.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);

        // Add notes about the implementation
        document.getElementById('notes').innerHTML = `
            <h3>Implementation Notes</h3>
            <p>This simulation features 60 bouncing balls with realistic physics:</p>
            <ul>
                <li>Gravity (0.2) applied to all balls</li>
                <li>Wall collisions with energy damping (80% retention)</li>
                <li>Ball-ball collisions with physics-based response</li>
                <li>Grid-based spatial partitioning for collision detection (20x15 grid)</li>
                <li>Optimized to handle 60+ balls smoothly at 60 FPS</li>
            </ul>
            <p>The grid optimization reduces collision checks from O(nÂ²) to O(n) by only checking neighboring cells, making the simulation efficient even with many balls.</p>
        `;
    </script>
    <section id="notes">
        <!-- Notes will be populated by JavaScript -->
    </section>
</body>
</html>