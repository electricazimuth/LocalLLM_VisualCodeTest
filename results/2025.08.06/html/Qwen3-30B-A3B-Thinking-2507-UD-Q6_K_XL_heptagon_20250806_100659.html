<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in a Spinning Heptagon</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas { 
            border: 1px solid #333; 
            background-color: #fff; 
            display: block; 
            margin: 20px auto;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
        h1 {
            margin-top: 15px;
            color: #2c3e50;
            text-align: center;
        }
        .instructions {
            max-width: 600px;
            margin: 15px auto;
            padding: 10px;
            background-color: #e8f4fc;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <h1>Bouncing Balls in a Spinning Heptagon</h1>
    <div class="instructions">
        <p>20 balls bounce inside a rotating heptagon container. Each ball has a unique number and color. The container spins at 360° per 5 seconds. Balls interact with each other and the container walls with realistic physics, including gravity, damping, and rotation.</p>
        <p>Click anywhere to reset the simulation.</p>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        
        // Configuration
        const NUM_BALLS = 20;
        const BALL_RADIUS = 15;
        const HEPTAGON_RADIUS = 220;
        const GRAVITY = 0.25;
        const DAMPING = 0.8;
        const ROTATION_SPEED = 2 * Math.PI / 5; // 360° per 5 seconds
        const COLORS = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51', 
            '#ee7948', '#ed6d3d', '#ec6800', '#ec6800', '#ee7800', 
            '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61', 
            '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];
        
        // Ball class for better organization
        class Ball {
            constructor(x, y, vx, vy, r, color, number) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.r = r;
                this.color = color;
                this.number = number;
                this.rotation = 0;
                this.rotationSpeed = 0;
            }
        }
        
        // Initialize balls
        function initBalls() {
            const balls = [];
            const center = { x: W/2, y: H/2 };
            
            for (let i = 0; i < NUM_BALLS; i++) {
                // Start near center with small random offsets
                const angle = i * (Math.PI * 2 / NUM_BALLS);
                const offset = 5;
                const x = center.x + Math.cos(angle) * offset;
                const y = center.y + Math.sin(angle) * offset;
                
                // Random initial velocity (small)
                const vx = (Math.random() - 0.5) * 3;
                const vy = (Math.random() - 0.5) * 3;
                
                balls.push(new Ball(
                    x, y, vx, vy, 
                    BALL_RADIUS, 
                    COLORS[i], 
                    i + 1
                ));
            }
            return balls;
        }
        
        // Calculate heptagon vertices for current rotation
        function getHeptagonVertices(center, radius, rotation) {
            const vertices = [];
            for (let i = 0; i < 7; i++) {
                const angle = rotation + i * (Math.PI * 2 / 7);
                vertices.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
            return vertices;
        }
        
        // Calculate normal vector for an edge (outward)
        function getEdgeNormal(v0, v1) {
            const edge = { x: v1.x - v0.x, y: v1.y - v0.y };
            const len = Math.sqrt(edge.x * edge.x + edge.y * edge.y);
            if (len === 0) return { x: 0, y: 0 };
            
            // Rotate edge 90 degrees clockwise for outward normal
            return {
                x: edge.y / len,
                y: -edge.x / len
            };
        }
        
        // Check if point is inside polygon (using ray casting)
        function isPointInsidePolygon(point, vertices) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const vi = vertices[i];
                const vj = vertices[j];
                if (((vi.y > point.y) !== (vj.y > point.y)) &&
                    (point.x < (vj.x - vi.x) * (point.y - vi.y) / (vj.y - vi.y) + vi.x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        // Main simulation variables
        let balls = initBalls();
        let currentAngle = 0;
        let lastTime = 0;
        let rotationDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        
        // Game loop
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;
            
            // Update rotation angle
            currentAngle += ROTATION_SPEED * deltaTime * rotationDirection;
            
            // Clear canvas
            ctx.clearRect(0, 0, W, H);
            
            // Draw background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, W, H);
            
            // Draw heptagon container
            const center = { x: W/2, y: H/2 };
            const vertices = getHeptagonVertices(center, HEPTAGON_RADIUS, currentAngle);
            
            // Draw heptagon
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 7; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw heptagon center
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(center.x, center.y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Update physics
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                
                // Apply gravity
                ball.vy += GRAVITY * deltaTime;
                
                // Update position
                ball.x += ball.vx * deltaTime;
                ball.y += ball.vy * deltaTime;
                
                // Update rotation (based on velocity)
                ball.rotation += ball.rotationSpeed * deltaTime;
                ball.rotationSpeed = ball.vx * 0.01 + ball.vy * 0.01;
            }
            
            // Handle wall collisions
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                let minSignedDistance = 0;
                let closestNormal = null;
                
                // Check against each edge of the heptagon
                for (let j = 0; j < 7; j++) {
                    const v0 = vertices[j];
                    const v1 = vertices[(j + 1) % 7];
                    const normal = getEdgeNormal(v0, v1);
                    
                    // Calculate signed distance from ball to edge
                    const edgeVector = { x: v1.x - v0.x, y: v1.y - v0.y };
                    const pointVector = { x: ball.x - v0.x, y: ball.y - v0.y };
                    const signedDistance = pointVector.x * normal.x + pointVector.y * normal.y;
                    
                    // Find the edge with the smallest (most negative) signed distance
                    if (signedDistance < minSignedDistance) {
                        minSignedDistance = signedDistance;
                        closestNormal = normal;
                    }
                }
                
                // If ball is outside the heptagon
                if (minSignedDistance < -ball.r) {
                    // Calculate displacement to move ball to boundary
                    const displacement = (-ball.r - minSignedDistance);
                    ball.x += displacement * closestNormal.x;
                    ball.y += displacement * closestNormal.y;
                    
                    // Apply bounce with damping
                    const dot = ball.vx * closestNormal.x + ball.vy * closestNormal.y;
                    ball.vx -= (1 + DAMPING) * dot * closestNormal.x;
                    ball.vy -= (1 + DAMPING) * dot * closestNormal.y;
                }
            }
            
            // Handle ball-ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    // Calculate distance between balls
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check for collision (distance < sum of radii)
                    if (distance < ball1.r + ball2.r) {
                        // Calculate normal vector
                        const nx = dx / distance;
                        const ny = dy / distance;
                        
                        // Move balls apart to prevent overlap
                        const overlap = (ball1.r + ball2.r) - distance;
                        ball1.x -= (overlap * nx) / 2;
                        ball1.y -= (overlap * ny) / 2;
                        ball2.x += (overlap * nx) / 2;
                        ball2.y += (overlap * ny) / 2;
                        
                        // Calculate relative velocity
                        const dvx = ball2.vx - ball1.vx;
                        const dvy = ball2.vy - ball1.vy;
                        const dot = dvx * nx + dvy * ny;
                        
                        // Only apply bounce if balls are moving toward each other
                        if (dot < 0) {
                            const delta = (1 + DAMPING) * dot / 2;
                            ball1.vx += delta * nx;
                            ball1.vy += delta * ny;
                            ball2.vx -= delta * nx;
                            ball2.vy -= delta * ny;
                        }
                    }
                }
            }
            
            // Draw balls
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                
                // Draw number on ball
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ball.number, ball.x, ball.y);
                
                // Draw rotation indicator (small circle)
                const rotationRadius = ball.r * 0.3;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, rotationRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw rotation indicator line
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(
                    ball.x + rotationRadius * Math.cos(ball.rotation),
                    ball.y + rotationRadius * Math.sin(ball.rotation)
                );
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw rotation indicator
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(
                `Rotation: ${Math.round(currentAngle * 180 / Math.PI) % 360}°`, 
                W/2, 20
            );
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Reset simulation
        function resetSimulation() {
            balls = initBalls();
            currentAngle = 0;
            lastTime = 0;
        }
        
        // Event listener for reset
        canvas.addEventListener('click', resetSimulation);
        
        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
    <section id="notes">
        <h2>Implementation Notes</h2>
        <p><strong>Physics Implementation:</strong></p>
        <ul>
            <li>Realistic gravity (0.25 px/s²) applied to all balls</li>
            <li>Wall collisions with damping (80% energy retention)</li>
            <li>Ball-ball collisions with elastic response and damping</li>
            <li>Rotation effect on balls based on velocity (spin indicator)</li>
        </ul>
        <p><strong>Optimizations:</strong></p>
        <ul>
            <li>Wall collision: Only check edges against balls (O(n*m) but m=7 is constant)</li>
            <li>Ball-ball collision: Only check pairs (O(n²) but n=20 is manageable)</li>
            <li>Efficient position correction to prevent overlap</li>
        </ul>
        <p><strong>Key Features:</strong></p>
        <ul>
            <li>Spinning heptagon container (360° per 5 seconds)</li>
            <li>20 uniquely colored balls with numbers 1-20</li>
            <li>Balls start from center with random initial velocities</li>
            <li>Realistic bounce height (within container boundaries)</li>
            <li>Rotation effect on balls based on velocity</li>
        </ul>
        <p><strong>Performance:</strong> The simulation runs smoothly at 60 FPS with 20 balls using vanilla JavaScript and Canvas.</p>
    </section>
</body>
</html>