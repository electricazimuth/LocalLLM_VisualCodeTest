<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Ray‑Marching Psychedelic Metaballs</title>
<style>
    body{margin:0;background:#000;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<canvas id="glCanvas"></canvas>

<!-- Vertex shader – just passes the vertex position to clip space -->
<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec2 aPosition;
varying vec2 vUV;
void main() {
    vUV = aPosition * 0.5 + 0.5;           // map [-1,1] → [0,1]
    gl_Position = vec4(aPosition, 0.0, 1.0);
}
</script>

<!-- Fragment shader – ray‑marching + smooth‑min metaballs -->
<script id="fragment-shader" type="x-shader/x-fragment">
precision highp float;
uniform float uTime;
uniform vec2 uResolution;
varying vec2 vUV;

// Signed distance to a sphere
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

// Smooth minimum (log‑exp) – blends two distances
float smin(float a, float b, float k) {
    return -log(exp(-k*a)+exp(-k*b))/k;
}

// Scene SDF – eight metaballs that move and change size over time
float map(vec3 p) {
    float d = 1e5;                    // start with a large distance
    const int N = 8;                  // number of metaballs
    const float k = 0.5;              // smoothness

    for(int i=0; i<N; ++i) {
        float t = uTime + float(i)*2.0;
        vec3 c = vec3(
            sin(t)*1.5,
            cos(t)*1.5,
            sin(t*0.5 + float(i))*1.5
        );
        float r = 0.4 + 0.15*sin(t + float(i));
        float dS = sdSphere(p - c, r);
        d = smin(d, dS, k);
    }
    return d;
}

// Approximate normal by central differences
vec3 getNormal(vec3 p) {
    const float eps = 0.001;
    float dx = map(p + vec3(eps,0,0)) - map(p - vec3(eps,0,0));
    float dy = map(p + vec3(0,eps,0)) - map(p - vec3(0,eps,0));
    float dz = map(p + vec3(0,0,eps)) - map(p - vec3(0,0,eps));
    return normalize(vec3(dx,dy,dz));
}

// Main rendering routine
void main() {
    // Normalized device coords
    vec2 uv = vUV;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= uResolution.x / uResolution.y;

    // Camera setup
    vec3 camPos = vec3(0.0, 0.0, -4.0);
    vec3 rayDir = normalize(vec3(p, 1.0));

    // Ray‑march loop
    float t = 0.0;
    const int MAX_STEPS = 128;
    const float MAX_DIST = 100.0;
    const float SURF_DIST = 0.002;
    bool hit = false;
    float dist = 0.0;

    for(int i=0; i<MAX_STEPS; ++i) {
        vec3 pos = camPos + t * rayDir;
        dist = map(pos);
        if(dist < SURF_DIST) { hit = true; break; }
        if(t > MAX_DIST) break;
        t += dist;
    }

    vec3 col;
    if(hit) {
        vec3 pos = camPos + t * rayDir;
        vec3 normal = getNormal(pos);

        // Simple Phong lighting
        vec3 lightDir = normalize(vec3(0.5, 0.8, 0.3));
        float diff = max(dot(normal, lightDir), 0.0);
        float spec = pow(max(dot(reflect(-lightDir, normal), -rayDir), 0.0), 32.0);

        // Psychedelic colour that drifts with position & time
        vec3 base = 0.5 + 0.5*sin(uTime + pos*3.0 + vec3(0.0,2.0,4.0));
        col = base * diff;
        col += vec3(1.0) * spec * 0.6;
    } else {
        col = vec3(0.0);                 // black background
    }

    // Gamma correction
    col = pow(col, vec3(0.4545));
    gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
(function() {
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) { alert('WebGL not supported'); return; }

    // --- Shader compilation helpers ---------------------------------------
    function compileShader(id, type) {
        const src = document.getElementById(id).textContent;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vert = compileShader('vertex-shader', gl.VERTEX_SHADER);
    const frag = compileShader('fragment-shader', gl.FRAGMENT_SHADER);

    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return;
    }
    gl.useProgram(program);

    // --- Fullscreen quad --------------------------------------------------
    const quadVerts = new Float32Array([
        -1, -1,   1, -1,   -1,  1,
        -1,  1,   1, -1,    1,  1
    ]);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

    const aPosLoc = gl.getAttribLocation(program, 'aPosition');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

    // --- Uniform locations -------------------------------------------------
    const uTimeLoc   = gl.getUniformLocation(program, 'uTime');
    const uResLoc    = gl.getUniformLocation(program, 'uResolution');

    // --- Resize handling ---------------------------------------------------
    function resize() {
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(uResLoc, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Animation loop ---------------------------------------------------
    let startTime = performance.now();
    function render() {
        const now = performance.now();
        const elapsed = (now - startTime) * 0.001;   // seconds
        gl.uniform1f(uTimeLoc, elapsed);

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
})();
</script>

<!-- Optional notes about the implementation -->
<section id="notes">
    <h2>Implementation Notes</h2>
    <ul>
        <li>Eight metaballs are generated procedurally in the fragment shader.  
            Their centres move on circular orbits and their radii pulse with a
            sine function.  This keeps the demo fully autonomous – no data
            needs to be sent from JavaScript after the initial uniforms.</li>
        <li>The scene SDF is built by repeatedly applying a smooth minimum
            (log‑exp) to all sphere distances.  This produces the classic
            “soft‑union” effect where spheres merge into a single organic
            shape.</li>
        <li>Ray marching uses a simple distance‑to‑surface heuristic.  The
            loop stops when the distance is below a small epsilon or when
            a maximum distance is exceeded.</li>
        <li>Lighting is a minimal Phong model.  The colour of each hit is
            modulated by a time‑varying sine pattern that gives the
            psychedelic feel.</li>
        <li>All calculations are performed in the fragment shader – the
            vertex shader is just a pass‑through that draws a full‑screen
            quad.</li>
    </ul>
</section>
</body>
</html>