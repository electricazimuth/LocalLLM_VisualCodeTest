<|channel|>analysis<|message|>We need to output a complete HTML with JavaScript implementing fireworks simulation per description. Use best practices: classes, array management, requestAnimationFrame, delta time, autonomous launch timers, gravity, etc. Provide code in the given boilerplate. Also include notes section perhaps.

Let's craft code.

Key details:
- canvas size 512x512, but should adapt to window? but we can keep.
- Use constants: GRAVITY = 0.0005? Actually per pixel per ms^2. Since delta time in ms, we can use gravity = 0.0005*? We'll calibrate.

- Rocket class: position, velocity, color, size maybe, fuseTime or targetHeight. We'll compute fuseTime random 1.5-2.5 sec. We'll store age.

- ExplosionParticle class: position, velocity, color, size, life, age.

- Manage particles array: both rockets and explosion particles; each object has type property (or use instanceof). Use update method.

- Launch rockets automatically: timer variable nextLaunch = 0; each frame, if time since last launch > random interval, spawn rocket and set nextLaunch.

- Use delta time (ms) convert to seconds (dt = (timestamp - lastTime)/1000). Use seconds for physics.

- Use requestAnimationFrame loop with timestamp param.

- For clearing canvas: fillRect with semi-transparent black for trailing effect? but requirement says clear.

- Draw: for rockets draw a small circle or line.

- Fade: compute alpha = remainingLife / totalLife.

- Remove particles: filter array each frame.

- Optimize removal: we can use while loop and swap/pop.

But simpler: new array for survivors.

- Use random color for rockets.

- Explosion particles count random 30-80.

- Provide variation.

- Use window resize to adjust canvas? Not required.

Let's craft code.

Pseudo:

class Rocket {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 30; // pixels per second
    this.vy = - (150 + Math.random() * 100); // upward speed
    this.color = randomColor();
    this.size = 3;
    this.age = 0;
    this.fuse = 1.5 + Math.random() * 0.5; // seconds until explosion
  }
  update(dt) {
    this.age += dt;
    this.vy += GRAVITY * dt; // gravity positive downward
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    if (this.age >= this.fuse || this.vy >= 0) {
      this.explode();
      return false; // remove rocket
    }
    return true;
  }
  explode() {
    const count = 30 + Math.floor(Math.random() * 50);
    for (let i=0;i<count;i++) {
      particles.push(new Spark(this.x, this.y, this.color));
    }
  }
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

class Spark {
  constructor(x, y, color) {
    const speed = 50 + Math.random()*150;
    const angle = Math.random()*Math.PI*2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.x = x;
    this.y = y;
    this.life = 1 + Math.random()*2; // seconds
    this.age = 0;
    this.color = color;
    this.size = 2 + Math.random()*2;
  }
  update(dt) {
    this.age += dt;
    if (this.age >= this.life) return false;
    this.vy += GRAVITY * dt;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    return true;
  }
  draw(ctx) {
    const alpha = 1 - this.age/this.life;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

const particles = [];

let lastTimestamp = 0;
let launchTimer = 0;
let nextLaunchDelay = randomLaunchDelay();

function randomLaunchDelay() {
  return 0.5 + Math.random() * 1.5; // seconds
}
function randomColor() {
  const hue = Math.floor(Math.random()*360);
  return `hsl(${hue}, 100%, 60%)`;
}

function spawnRocket() {
  const x = W/2 + (Math.random() - 0.5) * W * 0.2; // near center
  const y = H;
  particles.push(new Rocket(x, y));
}

function gameLoop(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const dt = (timestamp - lastTimestamp) / 1000; // seconds
  lastTimestamp = timestamp;

  // launch logic
  launchTimer += dt;
  if (launchTimer >= nextLaunchDelay) {
    spawnRocket();
    launchTimer = 0;
    nextLaunchDelay = randomLaunchDelay();
  }

  // update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    const alive = p.update(dt);
    if (!alive) {
      particles.splice(i, 1);
    }
  }

  // draw
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  for (const p of particles) {
    p.draw(ctx);
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

Add notes.

Make sure to use canvas width/height variables after possible resize.

Potential improvements: use requestAnimationFrame; handle high DPI (devicePixelRatio). Not required.

Add comments.

Will produce final HTML.

Let's craft final answer.<|start|>assistant<|channel|>final<|message|>**HTML (single file – copy‑paste into a blank *.html* and open in a browser)**  

```html
<!DOCTYPE html>
<html>
<head>
    <title>Fireworks Simulation</title>
    <style>
        body { margin:0; overflow:hidden; background:#111; }
        canvas { display:block; margin:0 auto; background:#000; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="512" height="512"></canvas>

    <script>
        /* --------------------------------------------------------------
         *  Fireworks – autonomous particle simulation
         *  -----------------------------------------------------------*/

        const canvas = document.getElementById('gameCanvas');
        const ctx     = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        /* --------------------------------------------------------------
         *  Global constants
         *  -----------------------------------------------------------*/
        const GRAVITY = 200;               // px / s² (downwards)
        const ROCKET_MIN_SPEED = 250;      // px / s (initial upward speed)
        const ROCKET_MAX_SPEED = 350;      // px / s
        const ROCKET_SPREAD    = 30;       // horizontal spread px / s
        const ROCKET_MIN_FUSE  = 1.2;      // seconds before explosion
        const ROCKET_MAX_FUSE  = 1.8;      // seconds

        const SPARK_MIN_SPEED = 60;        // px / s
        const SPARK_MAX_SPEED = 200;       // px / s
        const SPARK_MIN_COUNT = 30;
        const SPARK_MAX_COUNT = 80;
        const SPARK_MIN_LIFE  = 1.0;       // seconds
        const SPARK_MAX_LIFE  = 2.5;       // seconds

        /* --------------------------------------------------------------
         *  Helper utilities
         *  -----------------------------------------------------------*/
        function rand(min, max) { return Math.random() * (max - min) + min; }

        function randomColor() {
            // bright, fully‑saturated colours (hsl)
            const hue = Math.floor(Math.random() * 360);
            return `hsl(${hue},100%,60%)`;
        }

        function randomLaunchDelay() {
            // 0.5 – 2 seconds between launches
            return rand(0.5, 2);
        }

        /* --------------------------------------------------------------
         *  Particle classes
         *  -----------------------------------------------------------*/
        class Rocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = rand(-ROCKET_SPREAD, ROCKET_SPREAD);
                this.vy = -rand(ROCKET_MIN_SPEED, ROCKET_MAX_SPEED);
                this.color = randomColor();
                this.size  = 3;
                this.age   = 0;
                this.fuse  = rand(ROCKET_MIN_FUSE, ROCKET_MAX_FUSE);
            }

            update(dt) {
                this.age += dt;
                this.vy += GRAVITY * dt;          // gravity pulls down
                this.x  += this.vx * dt;
                this.y  += this.vy * dt;

                // explode either when fuse expires or when upward motion stops
                if (this.age >= this.fuse || this.vy >= 0) {
                    this.explode();
                    return false;                 // remove rocket from array
                }
                return true;
            }

            explode() {
                const count = Math.floor(rand(SPARK_MIN_COUNT, SPARK_MAX_COUNT));
                for (let i = 0; i < count; i++) {
                    particles.push(new Spark(this.x, this.y, this.color));
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Spark {
            constructor(x, y, color) {
                const speed = rand(SPARK_MIN_SPEED, SPARK_MAX_SPEED);
                const angle = rand(0, Math.PI * 2);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.x  = x;
                this.y  = y;
                this.color = color;
                this.size  = rand(2, 4);
                this.life  = rand(SPARK_MIN_LIFE, SPARK_MAX_LIFE);
                this.age   = 0;
            }

            update(dt) {
                this.age += dt;
                if (this.age >= this.life) return false; // dead

                this.vy += GRAVITY * dt;
                this.x  += this.vx * dt;
                this.y  += this.vy * dt;
                return true;
            }

            draw(ctx) {
                const alpha = 1 - this.age / this.life; // fade out
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        /* --------------------------------------------------------------
         *  Global state
         *  -----------------------------------------------------------*/
        const particles = [];                     // rockets + sparks
        let lastTimestamp = 0;
        let launchTimer   = 0;
        let nextLaunch    = randomLaunchDelay();

        function spawnRocket() {
            // launch from the bottom centre, with a small horizontal spread
            const x = W / 2 + rand(-W * 0.1, W * 0.1);
            const y = H;
            particles.push(new Rocket(x, y));
        }

        /* --------------------------------------------------------------
         *  Main loop – requestAnimationFrame
         *  -----------------------------------------------------------*/
        function gameLoop(timestamp) {
            // delta time in seconds (frame‑rate independent)
            if (!lastTimestamp) lastTimestamp = timestamp;
            const dt = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            /* ---- autonomous launching ---- */
            launchTimer += dt;
            if (launchTimer >= nextLaunch) {
                spawnRocket();
                launchTimer = 0;
                nextLaunch = randomLaunchDelay();
            }

            /* ---- update all particles ---- */
            for (let i = particles.length - 1; i >= 0; i--) {
                const alive = particles[i].update(dt);
                if (!alive) particles.splice(i, 1);      // efficient removal
            }

            /* ---- render ---- */
            ctx.fillStyle = '#000';                     // dark background
            ctx.fillRect(0, 0, W, H);

            for (const p of particles) p.draw(ctx);

            requestAnimationFrame(gameLoop);
        }

        // start the simulation
        requestAnimationFrame(gameLoop);
    </script>

    <section id="notes">
        <h2>Notes</h2>
        <ul>
            <li>All physics uses seconds as the time unit – the <code>dt</code> value makes the animation independent of the actual frame‑rate.</li>
            <li>Rockets and sparks share a single <code>particles</code> array to keep the update/draw loops simple.</li>
            <li>Removal is performed by iterating backwards and <code>splice</code>‑ing dead items – O(n) with a very low constant factor.</li>
            <li>Colours are generated with <code>hsl()</code> for vivid, random hues.</li>
            <li>Feel free to tweak the constants (gravity, speeds, counts) to change the visual feel.</li>
        </ul>
    </section>
</body>
</html>
```

The page launches rockets automatically, lets them rise, explode into many colourful sparks, and lets those sparks fall under gravity while fading away. The simulation runs smoothly thanks to a single `requestAnimationFrame` loop, delta‑time handling, and efficient particle management. Enjoy the fireworks!

<!-- Benchmark Info -->
<!-- Backend: llamacpp -->
<!-- Model: gpt-oss-120b-BF16.gguf -->
<!-- Prompt: fireworks.md -->
<!-- Generation Time: 124.60s -->
<!-- Fallback Used: False -->