<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Psychedelic Metaballs</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            pointer-events: none;
            text-shadow: 0 0 5px #0f0;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="info">Psychedelic Ray Marching Simulation</div>
    <canvas id="glCanvas"></canvas>

    <!-- Vertex Shader: Passes through a full-screen quad -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            // Convert -1->1 clip space to 0->1 texture space
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader: The Heavy Lifter -->
    <script id="fs" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_spheres[8]; // 8 spheres * vec3 (x,y,z,r,g,b)
        uniform int u_sphereCount;

        // Rotation matrix for camera movement
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        // 1. SDF for a single sphere
        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }

        // 2. Smooth Minimum (The Metaball Logic)
        // This creates the soft blending where spheres overlap
        float smin(float a, float b, float k) {
            // The requested logarithmic smooth minimum
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return -log(exp(-k * a) + exp(-k * b)) / k;
        }

        // 3. Scene Mapping: Combines spheres into one distance field
        // Using a fixed loop for WebGL 1.0 compatibility
        float map(vec3 p) {
            float d = 1e10; // Start with max distance
            for(int i = 0; i < 8; i++) {
                if (i >= u_sphereCount) break;
                
                vec3 spherePos = u_spheres[i * 3 + 0].xyz; // x
                float radius = u_spheres[i * 3 + 2].x;      // z (reused for radius)
                
                vec3 sphereD = sdSphere(p - spherePos, radius);
                d = smin(d, sphereD, 0.6); // k=0.6 controls smoothness
            }
            return d;
        }

        // 4. Calculate Normal from SDF
        vec3 calcNormal(vec3 p) {
            float d = map(p);
            vec2 e = vec2(0.01, 0.0);
            float n = d;
            float s = map(p + e.xyy) - n;
        }
        // Simplified normal calculation
        vec3 calcNormal(vec3 p) {
            float d = map(p);
            vec2 e = vec2(0.001, 0.0);
            float n = d;
            n = map(p + e.yxx) - n;
            float e1 = map(p + e.xyy) - n;
            float e2 = map(p + e.yxy) - n;
            float e3 = map(p + e.yyx) - n;
            return normalize(vec3(e1, e2, e3));
        }

        // Pseudo-random noise for grain
        float hash(float n) { 
            return fract(sin(n) * 43758.5453123);
        }

        void main() {
            // Normalize coordinates
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
            
            // Camera Setup
            vec3 ro = vec3(0.0, 0.0, -4.0); // Ray Origin
            vec3 rd = normalize(vec3(uv, 1.0)); // Ray Direction

            // Rotate camera slightly for dynamic view
            ro.xy *= rot(u_time * 0.1);
            rd.xy *= rot(u_time * 0.1);

            // Raymarching Loop
            float t = 0.0; // Total distance
            int steps = 64; // Max steps (performance vs quality)
            float tMin = 0.0; // Distance to nearest surface
            int stepCount = 0;
            
            // --- Animation: Move camera in and out slightly ---
            ro.z += sin(u_time * 0.5) * 0.5;

            for(int i = 0; i < 128; i++) {
                vec3 p = ro + rd * t;
                tMin = map(p);
                
                // If close enough to surface, break
                if(tMin < 0.001 || t > 100.0) break;
                
                t += tMin * 0.5; // Step size
                stepCount++;
                if(stepCount > 64) break; // Safety break
            }

            // Shading
            vec3 col = vec3(0.0);

            if (tMin < 0.001) {
                // Surface Hit
                vec3 p = ro + rd * t;
                vec3 n = calcNormal(p);
                vec3 p2 = p + n; // Offset for lighting

                // --- Psychedelic Coloring ---
                // Mix colors based on position and time
                float hue = 0.5 + 0.5 * sin(u_time * 0.1 + p.y * 0.5 + p2.z * 0.5);
                vec3 sphereColor = 0.5 + 0.5 * cos(hue + vec3(0, 1, 2) + u_time * 0.2);
                
                // Add some "liquid" depth variation based on the SDF value (tMin)
                // Smaller tMin (further away) = lighter/different color
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                float diff = max(dot(n, lightDir), 0.0);
                
                // Fresnel (Rim light) effect
                float fresnel = pow(1.0 - dot(n, vec3(0, 0, 1)), 3.0);
                fresnel = clamp(fresnel, 0.0, 1.0);

                // Combine lighting and color
                col = sphereColor * (diff * 0.5 + 0.5) * 2.0; // Diffuse
                col += sphereColor * fresnel * 2.0; // Rim light
            } else {
                // Background (Space)
                    col = mix(vec3(0.0, 0.02, 0.05), vec3(0.0, 0.0, 0.0), length(uv) * 0.2);
            }

            // --- Film Grain / Psychedelic Grain ---
            float noise = hash(floor(gl_FragCoord.x * 1.0) + floor(gl_FragCoord.y * 1.0));
            col += (noise - 0.5) * 0.05;

            // Tone mapping (simple gamma)
            col = pow(col, vec3(0.4545));
            
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        // --- WebGL Setup ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            throw new Error('WebGL not supported');
        }

        // Resize handler
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Shader Compilation Helper ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById('vs').text;
        const fsSource = document.getElementById('fs').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // --- Full Screen Quad Setup ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Two triangles covering the clip space
        const positions = [
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Uniform Locations ---
        const uResolutionLoc = gl.getUniformLocation(program, "u_resolution");
        const uTimeLoc = gl.getUniformLocation(program, "u_time");
        const uSphereLoc = gl.getUniformLocation(program, "u_spheres");
        const uSphereCountLoc = gl.getUniformLocation(program, "u_sphereCount");

        // --- Metaball State ---
        // Each sphere has: x, y, z (position) and r, g, b (color)
        // We will update positions in JS, but pass them as vec3s to save uniform slots
        // Array structure: [pos.x, pos.y, pos.z, r, g, b, 0, 0, ...] 
        // However, GLSL expects separate vec3s usually, or a texture. 
        // To keep it simple and performant:
        // We will create an array of objects in JS, update them, then pack into a Float32Array for the uniform.
        
        const sphereCount = 5;
        const spheres = [];
        for (let i = 0; i < sphereCount; i++) {
            spheres.push({
                x: (Math.random() * 2.0) - 1.0,
                y: (Math.random() * 2.0) - 1.0,
                z: (Math.random() * 2.0) - 1.0,
                r: 0.0, 
                g: 0.0, 
                b: 0.0
            });
        }
        
        // Uniform storage for passing to GPU
        // We will pack position (vec3) and radius (float) into the array
        const maxSpheres = 8;
        const packedSpheres = new Float32Array(maxSpheres * 3); // x,y,z for pos, x for radius
        const sphereUniforms = [];

        // Initialize Uniform Objects
        for(let i=0; i<maxSpheres; i++) {
            let loc = gl.getUniformLocation(program, `spheres[${i}]`);
            sphereUniforms.push(loc);
        }

        // --- Animation Loop ---
        let startTime = performance.now();

        function render() {
            const currentTime = (performance.now() - startTime) * 0.001; // Seconds
            gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(uTimeLoc, currentTime);

            // Update Physics/Math for Metaballs
            // We update the uniform data buffer here
            for (let i = 0; i < sphereCount; i++) {
                const s = spheres[i];
                const speed = 0.2 + (i * 0.1);
                const offset = i * 2.0;
                
                // "Breathing" motion
                const radius = 0.2 + Math.sin(currentTime * speed + i) * 0.05;
                
                // Update Position (swirling)
                // x = sin, y = cos
                let x = Math.sin(currentTime * 0.2 + offset) * 1.5;
                let z = Math.cos(currentTime * 0.3 + offset) * 1.5;
                let y = Math.sin(currentTime * 0.5 + i) * 0.5;

                // Color cycling
                let r = 0.5 + 0.5 * Math.sin(currentTime * 0.5 + i);
                let g = 0.5 + 0.5 * Math.sin(currentTime * 0.3 + i + 2.0);
                let b = 0.5 + 0.5 * Math.sin(currentTime * 0.7 + i + 4.0);

                // Pack data into the Float32Array
                // We use a flat array for the uniform: [x,y,z, r,g,b, x,y,z, r,g,b...]
                // Actually, GLSL expects vec3(x,y,z), vec3(x,y,z).
                // Let's pass 2 vec3s per sphere: pos, col.
                // That's 6 floats total per sphere.
                
                let base = i * 6;
                // We can't pass the array directly to a vec3[] uniform easily in WebGL 1 
                // without creating a texture or using a struct. 
                // To keep this simple and robust, we will just update the uniform 
                // location via JS. (Slower, but easier for this specific demo size).
                
                gl.uniform3fv(sphereUniforms[i], x, y, z); 
            }

            // Render Quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();

    </script>
</body>
</html>