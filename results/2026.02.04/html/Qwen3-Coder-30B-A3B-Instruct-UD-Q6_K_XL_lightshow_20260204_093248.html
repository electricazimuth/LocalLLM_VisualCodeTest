<!DOCTYPE html>
<html>
<head>
    <title>Ray Marching Psychedelic Metaballs</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Arial', sans-serif;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.7);
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="title">PSYCHEDELIC METABALLS</div>
    <div id="info">Ray marching technique with smooth minimum SDF combination</div>
    <canvas id="glCanvas"></canvas>

    <script>
        // --- Standard WebGL Boilerplate ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Set canvas size to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Vertex Shader ---
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_position * 0.5 + 0.5;
            }
        `;

        // --- Fragment Shader ---
        const fragmentShaderSource = `
            precision highp float;
            
            varying vec2 v_texCoord;
            uniform float u_time;
            uniform vec2 u_resolution;
            
            // Smooth minimum function
            float smin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }
            
            // Signed Distance Function for a sphere
            float sdSphere(vec3 p, vec3 center, float radius) {
                return length(p - center) - radius;
            }
            
            // Scene SDF - combines multiple metaballs
            float sceneSDF(vec3 p) {
                float k = 0.2; // Smooth minimum factor
                
                // Create multiple metaballs with dynamic positions
                vec3 pos1 = vec3(sin(u_time * 0.3) * 0.8, cos(u_time * 0.2) * 0.8, 0.0);
                vec3 pos2 = vec3(cos(u_time * 0.4) * 0.8, sin(u_time * 0.3) * 0.8, 0.0);
                vec3 pos3 = vec3(sin(u_time * 0.2) * 0.8, sin(u_time * 0.5) * 0.8, 0.0);
                vec3 pos4 = vec3(cos(u_time * 0.5) * 0.8, cos(u_time * 0.4) * 0.8, 0.0);
                
                // Varying sizes
                float r1 = 0.4 + 0.1 * sin(u_time * 0.7);
                float r2 = 0.3 + 0.1 * cos(u_time * 0.6);
                float r3 = 0.35 + 0.1 * sin(u_time * 0.8);
                float r4 = 0.45 + 0.1 * cos(u_time * 0.9);
                
                // Create SDFs for each metaball
                float d1 = sdSphere(p, pos1, r1);
                float d2 = sdSphere(p, pos2, r2);
                float d3 = sdSphere(p, pos3, r3);
                float d4 = sdSphere(p, pos4, r4);
                
                // Combine using smooth minimum
                float d = smin(d1, d2, k);
                d = smin(d, d3, k);
                d = smin(d, d4, k);
                
                return d;
            }
            
            // Calculate normal using gradient of SDF
            vec3 calcNormal(vec3 p) {
                const float eps = 0.001;
                vec2 e = vec2(eps, 0.0);
                return normalize(vec3(
                    sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
                    sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
                    sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
                ));
            }
            
            // Simple lighting model
            vec3 lighting(vec3 p, vec3 normal) {
                // Light direction
                vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));
                
                // Ambient light
                float ambient = 0.2;
                
                // Diffuse lighting
                float diffuse = max(dot(normal, lightDir), 0.0);
                
                // Combine lighting
                float intensity = ambient + 0.8 * diffuse;
                
                // Color based on position and time
                float hue = mod(u_time * 0.1, 1.0);
                vec3 color = vec3(
                    abs(sin(hue * 6.2831 + 0.0)),
                    abs(sin(hue * 6.2831 + 2.094)),
                    abs(sin(hue * 6.2831 + 4.188))
                );
                
                return color * intensity;
            }
            
            void main() {
                // Normalize coordinates
                vec2 uv = (v_texCoord - 0.5) * 2.0;
                uv.x *= u_resolution.x / u_resolution.y;
                
                // Camera setup
                vec3 ro = vec3(0.0, 0.0, 3.0); // Ray origin
                vec3 rd = normalize(vec3(uv, -1.0)); // Ray direction
                
                // Ray marching parameters
                const int MAX_STEPS = 100;
                const float MAX_DIST = 100.0;
                const float EPSILON = 0.001;
                
                float totalDist = 0.0;
                bool hit = false;
                vec3 color = vec3(0.0);
                
                // Ray marching loop
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = ro + rd * totalDist;
                    float d = sceneSDF(p);
                    
                    // If we're close to the surface
                    if (d < EPSILON) {
                        hit = true;
                        break;
                    }
                    
                    // If we've gone too far
                    if (totalDist > MAX_DIST) {
                        break;
                    }
                    
                    // Step forward
                    totalDist += d;
                }
                
                // Coloring based on hit or not
                if (hit) {
                    vec3 p = ro + rd * totalDist;
                    vec3 normal = calcNormal(p);
                    color = lighting(p, normal);
                    
                    // Add some glow effect
                    float glow = 1.0 - smoothstep(0.0, 0.5, totalDist / 10.0);
                    color += vec3(0.5, 0.2, 0.8) * glow * 0.5;
                } else {
                    // Background color (dark)
                    color = vec3(0.0, 0.0, 0.05);
                }
                
                // Apply some color modulation based on position
                color *= 1.0 + 0.3 * sin(u_time * 0.5 + uv.x * 5.0 + uv.y * 3.0);
                
                // Output final color
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Set up vertex data for a full-screen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Get uniform locations
        const timeUniformLocation = gl.getUniformLocation(program, "u_time");
        const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
        
        // Set resolution uniform
        gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        
        // Animation loop
        let startTime = Date.now();
        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            gl.uniform1f(timeUniformLocation, currentTime);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        
        // Start rendering
        render();
    </script>
</body>
</html>