<!DOCTYPE html>
<html>
<head>
    <title>Autonomous Aquarium Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #e0f7fa; 
            font-family: sans-serif;
        }
        canvas { 
            display: block; 
            margin: 0 auto; 
            background-color: rgb(207, 247, 255); 
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }
        #notes {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            max-width: 300px;
            pointer-events: none;
            font-size: 0.85rem;
            color: #333;
            border-left: 4px solid #0288d1;
        }
        h2 { margin: 0 0 5px 0; font-size: 1.2rem; }
    </style>
</head>
<body>

    <canvas id="simulationCanvas" width="800" height="600"></canvas>

    <section id="notes">
        <h2>Simulation Notes</h2>
        <p><strong>Object-Oriented Design:</strong> The <code>Fish</code> class encapsulates position, velocity, and rendering logic.</p>
        <p><strong>Autonomy:</strong> Fish use a wandering algorithm (random slight direction changes) to simulate organic behavior.</p>
        <p><strong>Boundary Interaction:</strong> Fish detect wall proximity and apply repulsion forces to turn away smoothly rather than bouncing.</p>
        <p><strong>Rendering:</strong> Uses <code>requestAnimationFrame</code> with delta-time calculations for smooth motion on any refresh rate. Tail wiggling is calculated using sine waves.</p>
    </section>

    <script>
        // --- Configuration ---
        const CONFIG = {
            fishCount: 15,
            baseSpeed: 40, // pixels per second
            speedVariance: 15,
            turnSpeed: 2.0, // how fast they turn (radians per second)
            wallAvoidanceDist: 100, // distance from wall to start turning
            fishSize: 15, // base radius
            plantCount: 10
        };

        // --- Utility Functions ---
        const randomRange = (min, max) => Math.random() * (max - min) + min;
        const randomColor = () => {
            const colors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#FF9F43', '#54A0FF', '#5F27CD'];
            return colors[Math.floor(Math.random() * colors.length)];
        };

        // --- Background Plant Class (Static) ---
        class Seaweed {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.swayPhase = Math.random() * Math.PI * 2;
            }

            draw(ctx, time) {
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Draw a stylized weed that sways slightly
                const sway = Math.sin(time * 0.002 + this.swayPhase) * 10;
                
                ctx.moveTo(this.x, this.y + this.height);
                // Root is at bottom, tips move at top
                ctx.quadraticCurveTo(
                    this.x + this.width / 2, 
                    this.y + this.height / 2 + sway, 
                    this.x + this.width, 
                    this.y + this.height
                );
                ctx.quadraticCurveTo(
                    this.x + this.width / 2, 
                    this.y + sway, 
                    this.x, 
                    this.y
                );
                ctx.fill();
            }
        }

        // --- The Fish Class ---
        class Fish {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.width = w;
                this.height = h;
                
                // Randomize appearance
                this.size = randomRange(CONFIG.fishSize - 5, CONFIG.fishSize + 5);
                this.color = randomColor();
                this.speed = randomRange(CONFIG.baseSpeed, CONFIG.baseSpeed + CONFIG.speedVariance);
                
                // Movement: Angle in Radians
                this.angle = randomRange(0, Math.PI * 2);
                
                // Velocity derived from speed and angle
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                
                // Animation properties
                this.tailWiggleSpeed = randomRange(5, 10);
                this.tailWigglePhase = Math.random() * Math.PI;
            }

            update(dt, time) {
                // 1. Wandering Behavior
                // Occasionally nudge the angle slightly to create organic curves
                if (Math.random() < 0.02) {
                    this.angle += randomRange(-0.5, 0.5);
                }

                // 2. Boundary Detection & Interaction
                const margin = CONFIG.wallAvoidanceDist;
                
                // Calculate desired angle to move away from walls
                let turnForce = 0;

                if (this.x < margin) {
                    turnForce += 0.5; // Push right
                } else if (this.x > this.width - margin) {
                    turnForce -= 0.5; // Push left
                }

                if (this.y < margin) {
                    turnForce += 0.5; // Push down
                } else if (this.y > this.height - margin) {
                    turnForce -= 0.5; // Push up
                }

                // Apply smooth turning
                if (turnForce !== 0) {
                    // Determine shortest path to turn
                    const targetAngle = this.angle + turnForce;
                    // Simple approach: just nudge angle towards the force
                    this.angle += turnForce * CONFIG.turnSpeed * dt;
                }

                // Keep angle normalized between 0 and 2PI
                if (this.angle < 0) this.angle += Math.PI * 2;
                if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2;

                // 3. Update Position
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Hard Clamp to ensure fish never leaves canvas
                if (this.x < this.size) this.x = this.size;
                if (this.x > this.width - this.size) this.x = this.width - this.size;
                if (this.y < this.size) this.y = this.size;
                if (this.y > this.height - this.size) this.y = this.height - this.size;
            }

            draw(ctx, time) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Rotate to face direction of movement
                ctx.rotate(this.angle);

                // Draw Tail (Wiggle effect using Sine wave)
                const wiggle = Math.sin(time * 0.01 * this.tailWiggleSpeed + this.tailWigglePhase) * 5;
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // Tail is at the back (negative X relative to center)
                ctx.moveTo(-this.size, 0); 
                ctx.lineTo(-this.size * 2, -5 + wiggle);
                ctx.lineTo(-this.size * 2, 5 + wiggle);
                ctx.fill();

                // Draw Body (Fusiform shape - Oval/Tapered)
                ctx.beginPath();
                // Start from head (right side)
                ctx.ellipse(0, 0, this.size * 1.5, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw Eye
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(this.size, -this.size * 0.2, this.size * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.size + 2, -this.size * 0.2, this.size * 0.1, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // --- Main Simulation Setup ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        let fishArray = [];
        let plantsArray = [];
        let lastTime = 0;

        function init() {
            // Create Fish
            for (let i = 0; i < CONFIG.fishCount; i++) {
                const startX = randomRange(50, W - 50);
                const startY = randomRange(50, H - 50);
                fishArray.push(new Fish(startX, startY, W, H));
            }

            // Create Background Plants
            for (let i = 0; i < CONFIG.plantCount; i++) {
                const px = randomRange(20, W - 20);
                const py = H; // Bottom of screen
                const pHeight = randomRange(50, 150);
                const pWidth = randomRange(10, 30);
                const pColor = Math.random() > 0.5 ? '#2e7d32' : '#1b5e20'; // Dark green shades
                plantsArray.push(new Seaweed(px, py - pHeight, pWidth, pHeight, pColor));
            }
        }

        function drawBackground(time) {
            // Clear Screen
            ctx.clearRect(0, 0, W, H);

            // Draw Background Bubbles (Simple decoration)
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            for(let i=0; i<10; i++) {
                // Use time to create slow rising movement
                const bx = (i * 73 + time * 0.05) % W;
                const by = (H - 10 - (time * 0.05 + i * 30) % H);
                ctx.beginPath();
                ctx.arc(bx, by, 3 + (i % 3), 0, Math.PI*2);
                ctx.fill();
            }

            // Draw Plants
            plantsArray.forEach(plant => plant.draw(ctx, time));
        }

        function gameLoop(timestamp) {
            // Calculate Delta Time (in seconds)
            if (lastTime === 0) {
                lastTime = timestamp;
            }
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Clamp dt to prevent huge jumps if tab is inactive
            const safeDt = Math.min(dt, 0.1);

            // Update Loop
            drawBackground(timestamp);

            // Update and Draw Fish
            fishArray.forEach(fish => {
                fish.update(safeDt, timestamp);
                fish.draw(ctx, timestamp);
            });

            requestAnimationFrame(gameLoop);
        }

        // Start
        init();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>