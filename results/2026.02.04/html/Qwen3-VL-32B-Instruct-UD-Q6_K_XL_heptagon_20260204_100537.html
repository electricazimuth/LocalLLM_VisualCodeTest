<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in a Spinning Heptagon</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Constants
        const GRAVITY = 0.2;
        const DAMPING = 0.85; // Energy loss on collision
        const BALL_RADIUS = 15;
        const NUM_BALLS = 20;
        const BALL_COLORS = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51', '#ee7948', '#ed6d3d', '#ec6800',
            '#ec6800', '#ee7800', '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61', '#e45e32',
            '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];
        const HEPTAGON_SIDES = 7;
        const HEPTAGON_ROTATE_SPEED = Math.PI / (5 * 1000 / 60); // 360 degrees in 5 seconds = 72 deg/sec = 1.27 rad/sec
        const HEPTAGON_RADIUS = 250; // Radius from center to vertex
        const HEPTAGON_CENTER_X = W / 2;
        const HEPTAGON_CENTER_Y = H / 2;
        const BALL_MASS = 1; // Constant mass for all balls

        // Ball class
        class Ball {
            constructor(x, y, vx, vy, color, id) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.r = BALL_RADIUS;
                this.color = color;
                this.mass = BALL_MASS;
                this.id = id; // Number from 1 to 20
                this.angularVelocity = 0; // For spinning effect
                this.angularDamping = 0.95; // Friction for spin
            }

            // Apply gravity
            applyGravity() {
                this.vy += GRAVITY;
            }

            // Update position
            updatePosition() {
                this.x += this.vx;
                this.y += this.vy;

                // Apply angular friction
                this.angularVelocity *= this.angularDamping;
            }

            // Draw ball with number
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw number
                ctx.font = `${this.r - 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#000';
                ctx.fillText(this.id, this.x, this.y);
            }

            // Rotate for visual spin
            spin() {
                // Simple rotation for visual effect
                this.angularVelocity += 0.01 * Math.random() - 0.005; // Small random variation
            }
        }

        // Heptagon class
        class Heptagon {
            constructor(centerX, centerY, radius) {
                this.centerX = centerX;
                this.centerY = centerY;
                this.radius = radius;
                this.angle = 0; // Current rotation angle
                this.rotationSpeed = HEPTAGON_ROTATE_SPEED;
            }

            // Get vertices of heptagon
            getVertices() {
                const vertices = [];
                for (let i = 0; i < HEPTAGON_SIDES; i++) {
                    const angle = this.angle + (i * 2 * Math.PI) / HEPTAGON_SIDES;
                    vertices.push({
                        x: this.centerX + this.radius * Math.cos(angle),
                        y: this.centerY + this.radius * Math.sin(angle)
                    });
                }
                return vertices;
            }

            // Draw heptagon
            draw(ctx) {
                const vertices = this.getVertices();
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Update rotation
            update() {
                this.angle += this.rotationSpeed;
            }

            // Check if point is inside heptagon
            pointInside(x, y) {
                const vertices = this.getVertices();
                let inside = false;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    if (((vertices[i].y > y) !== (vertices[j].y > y)) &&
                        (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
                        inside = !inside;
                    }
                }

                return inside;
            }

            // Check if ball collides with heptagon wall
            ballCollision(ball) {
                const vertices = this.getVertices();
                let collision = false;
                let collisionNormal = { x: 0, y: 0 };

                // Check collision with each edge
                for (let i = 0; i < vertices.length; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % vertices.length];
                    const edge = { x: v2.x - v1.x, y: v2.y - v1.y };

                    // Normalize edge
                    const edgeLen = Math.sqrt(edge.x * edge.x + edge.y * edge.y);
                    if (edgeLen < 1e-6) continue; // Avoid division by zero

                    const normal = { x: edge.y / edgeLen, y: -edge.x / edgeLen }; // Perpendicular vector

                    // Distance from ball center to edge
                    const dx = ball.x - v1.x;
                    const dy = ball.y - v1.y;
                    const distToEdge = dx * normal.x + dy * normal.y;

                    // Check if ball is near edge
                    if (Math.abs(distToEdge) < ball.r) {
                        // Check if ball is within the edge segment
                        const dot = (dx * edge.x + dy * edge.y) / (edgeLen * edgeLen);
                        if (dot >= 0 && dot <= 1) {
                            collision = true;
                            collisionNormal = normal;
                            break;
                        }
                    }
                }

                if (collision) {
                    // Calculate bounce
                    const dotProduct = ball.vx * collisionNormal.x + ball.vy * collisionNormal.y;
                    const impulse = 2 * dotProduct * DAMPING;
                    ball.vx -= impulse * collisionNormal.x;
                    ball.vy -= impulse * collisionNormal.y;

                    // Move ball out of wall
                    const overlap = ball.r - Math.abs(distToEdge);
                    if (overlap > 0) {
                        ball.x += collisionNormal.x * overlap;
                        ball.y += collisionNormal.y * overlap;
                    }
                }

                return collision;
            }
        }

        // Create balls
        let balls = [];
        let heptagon = new Heptagon(HEPTAGON_CENTER_X, HEPTAGON_CENTER_Y, HEPTAGON_RADIUS);

        for (let i = 0; i < NUM_BALLS; i++) {
            // Start near center
            const x = HEPTAGON_CENTER_X + Math.random() * 20 - 10;
            const y = HEPTAGON_CENTER_Y + Math.random() * 20 - 10;
            const vx = (Math.random() - 0.5) * 3;
            const vy = (Math.random() - 0.5) * 3;
            const color = BALL_COLORS[i % BALL_COLORS.length];
            balls.push(new Ball(x, y, vx, vy, color, i + 1));
        }

        // Collision detection and response for ball-ball
        function checkBallCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];

                    // Distance between centers
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Check if balls are colliding
                    if (distance < ball1.r + ball2.r) {
                        // Calculate collision normal
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        // Calculate relative velocity
                        const relVx = ball2.vx - ball1.vx;
                        const relVy = ball2.vy - ball1.vy;
                        const relVelDot = relVx * normalX + relVy * normalY;

                        // If balls are moving away, skip
                        if (relVelDot > 0) continue;

                        // Calculate impulse
                        const impulse = -relVelDot * 2 * DAMPING / (ball1.mass + ball2.mass);

                        // Apply impulse
                        ball1.vx -= impulse * normalX * ball2.mass;
                        ball1.vy -= impulse * normalY * ball2.mass;
                        ball2.vx += impulse * normalX * ball1.mass;
                        ball2.vy += impulse * normalY * ball1.mass;

                        // Resolve overlap
                        const overlap = ball1.r + ball2.r - distance;
                        if (overlap > 0) {
                            const moveX = normalX * overlap * 0.5;
                            const moveY = normalY * overlap * 0.5;
                            ball1.x -= moveX;
                            ball1.y -= moveY;
                            ball2.x += moveX;
                            ball2.y += moveY;
                        }
                    }
                }
            }
        }

        // Optimization: Grid-based spatial partitioning for collision detection
        // We'll use a simple grid to reduce collision checks
        const GRID_SIZE = 50;
        const GRID_WIDTH = Math.ceil(W / GRID_SIZE);
        const GRID_HEIGHT = Math.ceil(H / GRID_SIZE);

        function createGrid() {
            const grid = [];
            for (let i = 0; i < GRID_WIDTH; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_HEIGHT; j++) {
                    grid[i][j] = [];
                }
            }
            return grid;
        }

        function addToGrid(grid, ball) {
            const gridX = Math.floor(ball.x / GRID_SIZE);
            const gridY = Math.floor(ball.y / GRID_SIZE);
            if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                grid[gridX][gridY].push(ball);
            }
        }

        function removeFromGrid(grid, ball) {
            const gridX = Math.floor(ball.x / GRID_SIZE);
            const gridY = Math.floor(ball.y / GRID_SIZE);
            if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                const index = grid[gridX][gridY].indexOf(ball);
                if (index > -1) {
                    grid[gridX][gridY].splice(index, 1);
                }
            }
        }

        function checkBallCollisionsOptimized() {
            // Create a grid for spatial partitioning
            const grid = createGrid();

            // Add balls to grid
            for (const ball of balls) {
                addToGrid(grid, ball);
            }

            // Check collisions within each grid cell and adjacent cells
            for (let i = 0; i < GRID_WIDTH; i++) {
                for (let j = 0; j < GRID_HEIGHT; j++) {
                    const cell = grid[i][j];
                    for (let k = 0; k < cell.length; k++) {
                        for (let l = k + 1; l < cell.length; l++) {
                            const ball1 = cell[k];
                            const ball2 = cell[l];
                            const dx = ball2.x - ball1.x;
                            const dy = ball2.y - ball1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < ball1.r + ball2.r) {
                                // Collision detected, handle it
                                const normalX = dx / distance;
                                const normalY = dy / distance;
                                const relVx = ball2.vx - ball1.vx;
                                const relVy = ball2.vy - ball1.vy;
                                const relVelDot = relVx * normalX + relVy * normalY;

                                if (relVelDot > 0) continue;

                                const impulse = -relVelDot * 2 * DAMPING / (ball1.mass + ball2.mass);
                                ball1.vx -= impulse * normalX * ball2.mass;
                                ball1.vy -= impulse * normalY * ball2.mass;
                                ball2.vx += impulse * normalX * ball1.mass;
                                ball2.vy += impulse * normalY * ball1.mass;

                                const overlap = ball1.r + ball2.r - distance;
                                if (overlap > 0) {
                                    const moveX = normalX * overlap * 0.5;
                                    const moveY = normalY * overlap * 0.5;
                                    ball1.x -= moveX;
                                    ball1.y -= moveY;
                                    ball2.x += moveX;
                                    ball2.y += moveY;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);

            // Update heptagon rotation
            heptagon.update();

            // Update balls: apply gravity, update position
            for (const ball of balls) {
                ball.applyGravity();
                ball.updatePosition();
            }

            // Check collisions with heptagon walls
            for (const ball of balls) {
                heptagon.ballCollision(ball);
            }

            // Check ball-to-ball collisions (optimized)
            checkBallCollisionsOptimized();

            // Draw heptagon
            heptagon.draw(ctx);

            // Draw balls
            for (const ball of balls) {
                ball.draw(ctx);
            }

            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
    <section id="notes">
        <p>This implementation features a spinning heptagon container with 20 balls bouncing inside, affected by gravity and damping. Balls collide with each other and the container walls, with energy loss upon collision.</p>
        <p>Optimization: Spatial partitioning using a grid reduces collision detection complexity from O(nÂ²) to approximately O(n).</p>
        <p>Physics: Realistic bouncing with damping, gravity, and ball-to-ball collision response using impulse-based physics.</p>
        <p>Visuals: Each ball displays its number and color as specified, with a spinning visual effect.</p>
    </section>
</body>
</html>