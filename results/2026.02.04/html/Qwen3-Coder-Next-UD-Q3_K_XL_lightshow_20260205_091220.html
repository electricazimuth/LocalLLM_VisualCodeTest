<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychedelic Ray Marching Metaballs</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff;
            font-family: sans-serif;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h1>Neon Liquids</h1>
        <p>Ray Marching + Smooth Min SDF</p>
    </div>
    <canvas id="glCanvas"></canvas>

    <!-- VERTEX SHADER: Simple pass-through for a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- FRAGMENT SHADER: The core logic -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;

        // Constants
        const float MAX_STEPS = 64;
        const float MAX_DIST = 20.0;
        const float SURF_DIST = 0.001; // Surface distance threshold

        // --- Noise Functions (Hash/Value Noise) ---
        // Simple pseudo-random noise function for texture generation
        float hash(vec2 p) {
            p = fract(p * vec2(123.34, 234.45));
            return fract(p.x + p.y);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        // --- SDF Operations ---

        // Sphere SDF: Returns distance from point p to sphere centered at c with radius r
        float sdSphere(vec3 p, vec3 c, float r) {
            return length(p - c) - r;
        }

        // Smooth Minimum: The key to metaballs. 
        // f: first distance, g: second distance, k: smoothness factor (higher = sharper edges)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            // Exponential smooth min (more organic look)
            return mix(a, b, h) - k * h * (1.0 - h);
        }

        // Generalized smooth min for N elements (iterative application)
        float sminList(float d1, float d2, float d3, float k) {
            float d = smin(d1, d2, k);
            return smin(d, d3, k);
        }

        // --- Scene SDF ---
        // Defines the position, size, and color of metaballs dynamically
        float Map(vec3 p, out vec3 color) {
            // Dynamic positions using sine/cosine
            float t = u_time * 0.6;
            
            // Metaball 1: Cyan/Blue
            vec3 c1 = vec3(
                sin(t * 0.7) * 1.5,
                cos(t * 0.9) * 1.5,
                sin(t * 0.5) * 1.0
            );
            float r1 = 1.2 + sin(t * 1.2) * 0.3;

            // Metaball 2: Magenta/Purple
            vec3 c2 = vec3(
                cos(t * 0.5) * 1.5,
                sin(t * 0.7) * 1.5,
                cos(t * 0.8) * 1.5
            );
            float r2 = 1.0 + cos(t * 1.5) * 0.4;

            // Metaball 3: Yellow/Green
            vec3 c3 = vec3(
                sin(t * 0.9) * cos(t * 0.4) * 2.0,
                sin(t * 0.6) * 1.5,
                sin(t * 1.3) * 1.0
            );
            float r3 = 1.1 + sin(t * 2.0) * 0.3;

            // Calculate distances
            float d1 = sdSphere(p, c1, r1);
            float d2 = sdSphere(p, c2, r2);
            float d3 = sdSphere(p, c3, r3);

            // Calculate Smooth Minimum
            // k=0.5 provides a good balance between merging and distinctness
            float d = sminList(d1, d2, d3, 0.5);

            // Color Blending Logic: 
            // We determine color based on which metaball was closest at the hit point.
            // We need to recalculate individual distances to mix colors
            float dist1 = sdSphere(p, c1, r1);
            float dist2 = sdSphere(p, c2, r2);
            float dist3 = sdSphere(p, c3, r3);

            // Soft weighting
            float w1 = exp(-2.0 * dist1 * dist1);
            float w2 = exp(-2.0 * dist2 * dist2);
            float w3 = exp(-2.0 * dist3 * dist3);
            float sum = w1 + w2 + w3;
            
            // Normalize weights
            w1 /= sum;
            w2 /= sum;
            w3 /= sum;

            // Psychedelic Palette
            vec3 col1 = vec3(0.0, 1.0, 1.0);       // Cyan
            vec3 col2 = vec3(1.0, 0.0, 1.0);       // Magenta
            vec3 col3 = vec3(1.0, 1.0, 0.0);       // Yellow
            
            // Add some time-based color shifting
            vec3 finalColor = (w1 * col1 + w2 * col2 + w3 * col3);
            
            // Add noise to surface for "liquid" texture
            float n = noise(p * 3.0) * 0.05;
            d += n; 

            color = finalColor;
            return d;
        }

        // --- Ray Marching Loop ---
        float RayMarch(vec3 ro, vec3 rd, out vec3 color) {
            float d = 0.0; // Total distance traveled
            vec3 p = ro;   // Current position

            for (int i = 0; i < MAX_STEPS; i++) {
                // Get scene distance
                float dTemp = Map(p, color);
                
                d += dTemp;
                p += rd * dTemp;

                // Hit surface
                if (dTemp < SURF_DIST || d > MAX_DIST) {
                    break;
                }
            }

            // If we hit something (d < MAX_DIST), we calculate lighting
            if (d < MAX_DIST) {
                // Calculate Normal via Gradient (Finite Differences)
                vec2 eps = vec2(0.001, 0.0);
                vec3 normal = normalize(vec3(
                    Map(p + eps.xyy, color) - Map(p - eps.xyy, color),
                    Map(p + eps.yxy, color) - Map(p - eps.yxy, color),
                    Map(p + eps.yyx, color) - Map(p - eps.yyx, color)
                ));

                // Lighting
                vec3 lightPos = vec3(2.0, 4.0, 5.0);
                vec3 lightDir = normalize(lightPos - p);
                
                // Diffuse
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Specular (Glow effect)
                float spec = pow(max(dot(reflect(-lightDir, normal), -rd), 0.0), 32.0);
                
                // Ambient Occlusion approximation (simple distance fade)
                float ao = 1.0 - (d / MAX_DIST);

                // Psychedelic Lighting: Shift colors based on normal
                vec3 baseCol = color;
                baseCol.r += sin(d * 2.0 + p.z) * 0.2;
                baseCol.g += cos(d * 2.0 + p.x) * 0.2;
                baseCol.b += sin(d * 1.0 + p.y) * 0.2;

                // Combine
                vec3 ambient = vec3(0.05, 0.05, 0.1); // Dark blue-ish ambient
                vec3 finalColor = (ambient + diff * baseCol + vec3(spec)) * ao;

                return d; // Return distance for fog calculation if needed
            }

            // Background (void)
            color = vec3(0.0);
            return -1.0;
        }

        void main() {
            // Normalize pixel coordinates (from 0 to 1)
            // Correct aspect ratio
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

            // Camera Setup
            vec3 ro = vec3(0.0, 0.0, 6.0); // Ray Origin (Camera position)
            
            // Slight camera movement for parallax effect
            ro.x += sin(u_time * 0.2) * 0.5;
            ro.y += cos(u_time * 0.3) * 0.5;
            
            vec3 rd = normalize(vec3(uv, -1.0)); // Ray Direction

            vec3 col = vec3(0.0);
            RayMarch(ro, rd, col);

            // Apply Tone Mapping / Gamma Correction
            col = pow(col, vec3(0.4545)); 

            // Add subtle chromatic aberration at edges
            float distFromCenter = length(uv);
            if (distFromCenter > 0.8) {
                float amount = (distFromCenter - 0.8) * 3.0;
                vec3 rShift = col.r * vec3(1.0, 0.8, 0.7);
                vec3 bShift = col.b * vec3(0.7, 0.8, 1.0);
                col = mix(col, rShift * 0.5 + bShift * 0.5, amount * 0.2);
            }

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        // --- JavaScript WebGL Boilerplate & Animation Logic ---
        
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Compile Shader Helper
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create Program Helper
        function createProgram(vSource, fSource) {
            const vShader = compileShader(vSource, gl.VERTEX_SHADER);
            const fShader = compileShader(fSource, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vShader);
            gl.attachShader(program, fShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Get Shader Sources
        const vSource = document.getElementById('vertex-shader').text;
        const fSource = document.getElementById('fragment-shader').text;

        const program = createProgram(vSource, fSource);
        gl.useProgram(program);

        // Setup Full Screen Quad (Two Triangles)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Coordinates: Bottom-Left(-1,-1), Bottom-Right(1,-1), Top-Left(-1,1)
        // Triangle Strip: 0, 1, 2 -> 0, 2, 3 (or just 6 indices)
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Setup Attributes
        const aPositionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(aPositionLocation);
        gl.vertexAttribPointer(aPositionLocation, 2, gl.FLOAT, false, 0, 0);

        // Setup Uniforms
        const uResolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const uTimeLocation = gl.getUniformLocation(program, 'u_time');

        // Handle Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(uResolutionLocation, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Animation Loop
        let startTime = Date.now();
        
        function render() {
            // Calculate time in seconds
            const currentTime = (Date.now() - startTime) / 1000.0;
            gl.uniform1f(uTimeLocation, currentTime);

            // Draw the quad (2 triangles = 6 vertices)
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // Start
        render();

    </script>

    <section id="notes">
        <h3>Implementation Notes</h3>
        <ul>
            <li><strong>SDF & Metaballs:</strong> The scene uses three dynamic spheres. The <code>smin</code> function (exponential smooth minimum) blends theirSigned Distance Functions, creating the organic "liquid" merging effect.</li>
            <li><strong>Color Mixing:</strong> Instead of just picking the closest object, the shader calculates soft weights based on the distance to each sphere. This creates a smooth gradient where colors blend like pigments rather than hard edges.</li>
            <li><strong>Psychedelic Effects:</strong> Colors are not static. They are modulated by the pixel's position in world space and the total ray distance, creating shifting rainbows. A noise function is applied to the SDF to create a "boiling" texture on the surface of the blobs.</li>
            <li><strong>Lighting:</strong> Standard Phong shading is implemented (Diffuse, Specular, Ambient). Ambient Occlusion is approximated by fading objects as the ray travels further into the scene.</li>
            <li><strong>Performance:</strong> The shader uses a fixed step count (64). If the ray travels too far (20 units), it exits early, assuming it hit the background void.</li>
        </ul>
    </section>
</body>
</html>