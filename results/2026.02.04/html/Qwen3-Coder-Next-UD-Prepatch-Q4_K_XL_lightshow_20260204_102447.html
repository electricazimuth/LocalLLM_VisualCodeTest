<!DOCTYPE html>
<html>
<head>
    <title>Ray Marching Psychedelic Metaballs</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="ui-layer">
        <div>PSYCHEDELIC RAY MARCHING</div>
        <div>Metaballs: Smooth Minimum SDF</div>
        <div>Rendering: 30 Steps / Pixel</div>
    </div>

    <!-- VERTEX SHADER -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            // Pass through coordinates for full screen quad
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- FRAGMENT SHADER -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_aspect;

        // Constants for the simulation
        #define MAX_STEPS 60
        #define MAX_DIST 20.0
        #define SURF_DIST 0.001
        
        // PALETTE FUNCTION for Psychedelic Colors
        // Returns vibrant HSL-like colors based on input
        vec3 palette( float t ) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            // Complex wave functions for cycling colors
            vec3 col = a + b*cos( 6.28318*(c*t + gl_FragCoord.xy/ u_resolution.x) );
            return col;
        }

        // --- SDF OPERATORS ---

        // Sphere SDF
        float sdSphere(vec3 p, float s) {
            return length(p) - s;
        }

        // Smooth Minimum (The core of metaballs)
        // k is the blending factor. Higher k = harder edges, Lower k = more merging
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            // Polynomial smooth min (stable and fast)
            return mix(a, b, h) - k * h * (1.0 - h);
        }
        
        // Alternative Exponential Smooth Min (softer blend)
        float smin_exp(float a, float b, float k) {
            float res = -log(exp(-k*a) + exp(-k*b)) / k;
            return res;
        }

        // --- SCENE DEFINITION ---

        float MapScene(vec3 p) {
            // Create dynamic positions based on time
            // Using sine/cosine to create looping organic motion
            float t = u_time * 0.4;
            
            // Define 3 main Metaballs
            vec3 ball1Pos = vec3(
                sin(t) * 1.5,
                cos(t * 1.3) * 1.5,
                sin(t * 0.5) * 2.0
            );
            
            vec3 ball2Pos = vec3(
                cos(t * 0.7) * 1.8,
                sin(t * 0.9) * 1.8,
                cos(t * 1.1) * 2.0
            );

            vec3 ball3Pos = vec3(
                sin(t * 1.5 + 2.0) * 2.0,
                cos(t * 1.2) * 2.0,
                sin(t * 0.3) * 2.0
            );

            // Radius of the balls
            float r1 = 1.2 + 0.3 * sin(t * 2.0);
            float r2 = 1.0 + 0.2 * cos(t * 3.0);
            float r3 = 1.4 + 0.4 * sin(t * 1.7);

            // Calculate distances to each sphere
            float d1 = sdSphere(p - ball1Pos, r1);
            float d2 = sdSphere(p - ball2Pos, r2);
            float d3 = sdSphere(p - ball3Pos, r3);

            // Combine them using Smooth Minimum
            // We chain smin: combine 1&2, then result with 3
            // Using a lower k value (0.5) creates a very "liquid" merging effect
            float d = smin(d1, d2, 0.6);
            d = smin(d, d3, 0.6);

            // Add a subtle repeating floor pattern for reference/scale
            // vec3 gridPos = mod(p, 4.0) - 2.0;
            // float grid = sdSphere(gridPos, 0.2);
            // d = smin(d, grid, 2.0); 

            return d;
        }

        // Ray Marching Loop
        float RayMarch(vec3 ro, vec3 rd) {
            float d = 0.0;
            float dMin = 10.0; // Closest distance found so far
            
            for (int i = 0; i < MAX_STEPS; i++) {
                vec3 p = ro + rd * d;
                float dist = MapScene(p);
                
                // Store closest approach for coloring
                if(dist < dMin) dMin = dist;
                
                d += dist;
                
                // If we hit a surface (dist is very small) or went too far
                if (d > MAX_DIST || dist < SURF_DIST) {
                    break;
                }
            }
            
            if (d > MAX_DIST) {
                return -1.0; // Missed everything
            }
            
            return d;
        }

        // Calculate Normal for Lighting
        // Uses central differences (gradient of the SDF)
        vec3 GetNormal(vec3 p) {
            const float eps = 0.001;
            const vec2 h = vec2(eps, 0.0);
            
            float d = MapScene(p);
            vec3 n = d - vec3(
                MapScene(p - h.xyy),
                MapScene(p - h.yxy),
                MapScene(p - h.yyx)
            );
            
            return normalize(n);
        }

        // Lighting Calculation
        float CalculateAO(vec3 p, vec3 n) {
            float ao = 0.0;
            float scale = 1.0;
            for(int i = 1; i <= 5; i++) {
                float dist = float(i) * 0.1;
                float d = MapScene(p + n * dist);
                ao += (dist - d) * scale;
                scale *= 0.8;
            }
            return clamp(1.0 - ao, 0.0, 1.0);
        }

        void main() {
            // Normalize pixel coordinates (from -1 to 1)
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
            
            // Camera Setup
            vec3 ro = vec3(0.0, 0.0, -5.0); // Ray Origin (Camera position)
            
            // Simple Camera Animation (Orbit)
            vec3 target = vec3(0.0, 0.0, 0.0);
            float camRotX = sin(u_time * 0.3) * 0.5;
            float camRotY = cos(u_time * 0.2) * 0.5;
            
            // Rotation Matrices
            float cx = cos(camRotX); float sx = sin(camRotX);
            float cy = cos(camRotY); float sy = sin(camRotY);
            
            // Calculate ray direction with simple perspective
            vec3 rd = normalize(vec3(uv.x, uv.y, 1.5)); 

            // Apply camera rotation to ray direction
            vec3 right = vec3(cy, 0.0, -sy);
            vec3 up = vec3(sx * sy, cx, cx * sy);
            vec3 forward = vec3(cx * sy, -sx, cx * cy);
            
            // Re-orthonormalize (optional, but good for high rotation)
            right = normalize(right - up * dot(right, up));
            up = normalize(forward cross right);
            
            rd = normalize(rd.x * right + rd.y * up + rd.z * forward);

            // RAY MARCH
            float d = RayMarch(ro, rd);
            
            vec3 finalColor = vec3(0.0);
            
            if (d > 0.0) {
                vec3 p = ro + rd * d;
                vec3 n = GetNormal(p);
                
                // ---Psychedelic Coloring Logic---
                
                // 1. Base Palette based on position and time
                float colT = u_time * 0.2 + length(p.xz);
                vec3 objColor = palette(colT);
                
                // 2. Lighting (Directional Light)
                vec3 lightDir = normalize(vec3(0.5, 1.0, -0.5));
                float diff = clamp(dot(n, lightDir), 0.0, 1.0);
                
                // 3. Specular Highlight
                vec3 viewDir = normalize(ro - p);
                vec3 reflectDir = reflect(-lightDir, n);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                
                // 4. Ambient Occlusion
                float ao = CalculateAO(p, n);
                
                // Combine
                vec3 lighting = vec3(0.2); // Ambient
                lighting += vec3(0.8) * diff * ao; // Diffuse
                lighting += vec3(1.0) * spec * 0.5; // Specular
                
                // 5. Distance Fog (Depth Cueing)
                float fog = 1.0 / (1.0 + d * d * 0.1);
                finalColor = objColor * lighting * fog;
                
                // Add a "glow" based on how close we got to the surface
                // This enhances the volumetric feel
                float intensity = 1.0 - (d / MAX_DIST);
                finalColor += objColor * intensity * 0.2;

            } else {
                // Background: Deep space black with subtle noise
                finalColor = vec3(0.01 * sin(u_time + uv.x * 10.0) * sin(u_time + uv.y * 10.0));
            }

            // Gamma Correction (approximate)
            finalColor = pow(finalColor, vec3(0.4545));
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- JavaScript Logic ---

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', { alpha: false, antialias: false });

        if (!gl) {
            alert('WebGL not supported');
        }

        // 1. Compile Shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // 2. Link Program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        // 3. Set up Geometry (Full Screen Quad)
        // Two triangles covering the clip space (-1 to 1)
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
            -1,  1,
             1, -1,
             1,  1,
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // 4. Setup Uniforms
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const aspectLocation = gl.getUniformLocation(program, 'u_aspect');

        // 5. Render Loop
        let lastTime = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function render(timestamp) {
            // Calculate delta time (not strictly necessary for this visual, but good practice)
            // const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Update Uniforms
            const time = timestamp / 1000; // Seconds
            gl.useProgram(program);
            
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(aspectLocation, canvas.width / canvas.height);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        // Notes Section for Implementation Details
        /*
        DEVELOPER NOTES:

        1. SDF (Signed Distance Function):
           - The core of ray marching. `sdSphere` returns the distance to the sphere surface.
           - A negative value implies the point is inside the sphere.
           
        2. Metaballs (Smooth Minimum):
           - Regular minimum (`min(a,b)`) creates hard edges (CSG Union).
           - `smin(a, b, k)` creates a blend. `k` controls the "softness".
           - We used the polynomial formulation `mix(a,b,h) - k*h*(1-h)` as it is faster 
             and more numerically stable than the exponential version `log(exp(-ka)+exp(-kb))/k`.
           
        3. Coloring (Psychedelic):
           - Instead of fixed colors, we used a cosine-based palette function driven by 
             time and 3D position (`colT`).
           - This ensures the colors cycle continuously and shift based on where the ray 
             hits within the volume.
           
        4. Lighting & Shading:
           - Standard Phong lighting is applied: Ambient + Diffuse + Specular.
           - Normal calculation uses the "central differences" method: sampling the SDF 
             around the hit point to find the gradient (slope).
           - Ambient Occlusion approximation: stepping along the normal to see how much 
             free space exists nearby, darkening crevices.
           
        5. Performance:
           - `MAX_STEPS` is set to 60. Fewer steps = faster but blocky. More steps = smoother 
             but heavier on the GPU.
           - We avoid texture lookups (noise) to keep the shader self-contained and fast.
         */
    </script>
</body>
</html>