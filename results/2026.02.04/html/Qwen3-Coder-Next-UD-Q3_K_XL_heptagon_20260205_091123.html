<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in Spinning Heptagon</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #333; 
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas { 
            border: 4px solid #555; 
            background-color: #fff; 
            display: block; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            margin: 20px auto; 
            cursor: crosshair;
        }
        #ui-layer {
            text-align: center;
            color: #333;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .btn {
            padding: 8px 16px;
            background-color: #f39800;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        .btn:hover { background-color: #d66a35; }
        section#notes {
            margin: 0 20px 20px 20px;
            padding: 15px;
            background-color: #eef;
            border-radius: 8px;
            border-left: 5px solid #4a90e2;
            max-width: 600px;
            line-height: 1.6;
            color: #555;
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; color: #333; }
        p { margin: 5px 0; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1>Spinning Heptagon Physics</h1>
        <p>20 Balls &bull; Gravity &bull; Friction &bull; Rotational Energy Transfer</p>
        <button class="btn" onclick="resetSimulation()">Reset Balls</button>
        <button class="btn" onclick="togglePause()" id="pauseBtn">Pause</button>
    </div>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <section id="notes">
        <h3>Implementation Notes</h3>
        <p><strong>Physics Engine:</strong> This simulation uses a custom-written physics loop without external libraries.</p>
        <p><strong>Heptagon Math:</strong> The container is defined by 7 vertices. The rotation is calculated based on 360 degrees per 5 seconds (0.72 rad/s). The walls are treated as line segments.</p>
        <p><strong>Wall Collision (Response):</strong> We use the "Static Resolution" method. First, we detect if the ball intersects any wall. We calculate the Wall Normal vector. We resolve the ball's position to be exactly at the boundary (preventing sinking). Then we calculate the velocity reflection relative to the wall. Crucially, because the wall is moving (rotating), we add a tangential force component based on the rotation speed to simulate friction/spin transfer.</p>
        <p><strong>Ball Collision (Response):</strong> We use a spatial optimization (Grid/Sorting) to reduce O(n^2) checks. Collisions are resolved using 1D elastic collision logic along the collision normal, conserving momentum while applying a damping factor to simulate energy loss.</p>
        <p><strong>Spin & Numbers:</strong> Balls have a rotation property. When a ball hits a wall, especially a moving one, it imparts spin. The numbers rotate to visually indicate this spin.</p>
    </section>

<script>
/**
 * CONFIGURATION & CONSTANTS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// Physics Constants
const GRAVITY = 0.25;
const FRICTION = 0.99; // Air resistance
const WALL_BOUNCE_DAMPING = 0.8; // Energy kept after hitting wall
const BALL_BOUNCE_DAMPING = 0.85; // Energy kept after hitting ball
const SUB_STEPS = 8; // Physics accuracy (higher = better collision detection)
const ROTATION_SPEED_DEG_PER_SEC = 360 / 5; // 360 deg per 5 seconds

// Colors from prompt
const BALL_COLORS = [
    "#f8b862", "#f6ad49", "#f39800", "#f08300", "#ec6d51", 
    "#ee7948", "#ed6d3d", "#ec6800", "#ec6800", "#ee7800", 
    "#eb6238", "#ea5506", "#ea5506", "#eb6101", "#e49e61", 
    "#e45e32", "#e17b34", "#dd7a56", "#db8449", "#d66a35"
];

// State
let balls = [];
let heptagonAngle = 0;
let isPaused = false;
let lastTime = 0;

// Heptagon Configuration
const HEX_RADIUS = 200; // Radius of the container
const CENTER_X = W / 2;
const CENTER_Y = H / 2;
const BALL_RADIUS = 18;

/**
 * UTILITIES
 */
function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

// Rotate a point around a center
function rotatePoint(x, y, cx, cy, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const dx = x - cx;
    const dy = y - cy;
    return {
        x: cx - dx * cos + dy * sin,
        y: cy - dx * sin - dy * cos
    };
}

/**
 * BALL CLASS
 */
class Ball {
    constructor(id, x, y, color) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10; // Random initial velocity
        this.vy = (Math.random() - 0.5) * 10;
        this.r = BALL_RADIUS;
        this.color = color;
        this.mass = this.r * this.r; // Mass proportional to area
        this.angle = 0;
        this.angularVelocity = 0; // Rotation speed
        this.text = id.toString();
    }

    update() {
        // Apply Gravity
        this.vy += GRAVITY;
        
        // Apply Air Friction
        this.vx *= FRICTION;
        this.vy *= FRICTION;
        
        // Apply Angular Friction (Spin slows down)
        this.angularVelocity *= 0.99;

        // Update Position
        this.x += this.vx;
        this.y += this.vy;
        
        // Update Rotation
        this.angle += this.angularVelocity;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Draw Ball Body
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw Shine/Highlight
        ctx.beginPath();
        ctx.arc(-this.r * 0.3, -this.r * 0.3, this.r * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.fill();

        // Draw Number
        ctx.fillStyle = "#FFF";
        ctx.font = `bold ${this.r}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // Shadow for number
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fillText(this.text, 0, 0);

        ctx.restore();
    }
}

/**
 * INITIALIZATION
 */
function initBalls() {
    balls = [];
    for (let i = 0; i < 20; i++) {
        // Start at center with slight offset to prevent perfect stacking
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 10;
        const startX = CENTER_X + Math.cos(angle) * radius;
        const startY = CENTER_Y + Math.sin(angle) * radius;
        
        const color = BALL_COLORS[i % BALL_COLORS.length];
        balls.push(new Ball(i + 1, startX, startY, color));
    }
}

/**
 * COLLISION DETECTION HELPERS
 */
function getHeptagonVertices(angle) {
    const vertices = [];
    for (let i = 0; i < 7; i++) {
        const theta = angle + (i * 2 * Math.PI / 7);
        const x = CENTER_X + HEX_RADIUS * Math.cos(theta);
        const y = CENTER_Y + HEX_RADIUS * Math.sin(theta);
        vertices.push({x, y});
    }
    return vertices;
}

// Distance from point P to line segment AB
function distPointToSegment(px, py, ax, ay, bx, by) {
    const l2 = (ax - bx) ** 2 + (ay - by) ** 2;
    if (l2 === 0) return dist(px, py, ax, ay);
    
    let t = ((px - ax) * (bx - ax) + (py - ay) * (by - ay)) / l2;
    t = Math.max(0, Math.min(1, t));
    
    const projX = ax + t * (bx - ax);
    const projY = ay + t * (by - ay);
    
    return { dist: dist(px, py, projX, projY), projX, projY };
}

// Check if ball is strictly inside (for initial placement safety)
function isInsideHeptagon(ball, angle) {
    const vertices = getHeptagonVertices(angle);
    let inside = true;
    // Ray casting or point-side-of-line test
    for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        
        // Vector P1->P2
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        // Vector P1->Ball
        const bdx = ball.x - p1.x;
        const bdy = ball.y - p1.y;
        
        // Cross product Z component
        const cross = dx * bdy - dy * bdx;
        
        // For a convex polygon defined clockwise or counter-clockwise, 
        // the sign should be consistent. 
        // Let's assume standard math coordinates (Y up is easier, but Canvas Y is down).
        // We are using standard Canvas coords (Y down).
        // Heptagon vertices generated CCW? No, cos/sin is CCW.
        // In Canvas, Y is down. CCW means the interior is on the right side of vectors?
        // Let's use a simpler approach: Distance to segment < Radius AND Center Distance < Radius
        // Actually, for a convex container, the ball center must be on the "inside" of every wall.
        
        // Calculate vector normal pointing inward
        // Simplified: Check if ball is too far from center relative to wall distance
        // Best method: Point-Side test.
        
        // Let's use the "Wall Normal" method.
        // Vector Normal = (-dy, dx) normalized. 
        // Dot product with (Ball - P1).
        
        // Normal pointing INWARD for CCW polygon in Canvas (Y-down) usually requires checking specific logic.
        // Easier: Calculate distance from center (0,0) to the wall line. The ball center must be closer to center than the wall is.
        
        // Let's stick to the distance check for robustness:
        // If distance from ball to ANY segment is less than radius, it might be colliding or outside.
        // But for "Inside" check, we need to ensure it's within the boundary.
        
        // Robust Method:
        // Transform ball position to local space where heptagon is axis-aligned? No.
        // Let's use the standard Point-in-Polygon ray crossing algorithm.
        
        let c = false;
        let j = vertices.length - 1;
        for (let i = 0; i < vertices.length; i++) {
            const vi = vertices[i];
            const vj = vertices[j];
            if (((vi.y > ball.y) !== (vj.y > ball.y)) &&
                (ball.x < (vj.x - vi.x) * (ball.y - vi.y) / (vj.y - vi.y) + vi.x)) {
                c = !c;
            }
            j = i;
        }
        return c;
    }
}

/**
 * MAIN PHYSICS ENGINE
 */
function updatePhysics(dt) {
    const timeScale = dt / 16.67; // Normalize to ~60fps
    const rotationSpeedRadPerFrame = (ROTATION_SPEED_DEG_PER_SEC * (Math.PI / 180)) * timeScale;
    
    heptagonAngle += rotationSpeedRadPerFrame;
    const vertices = getHeptagonVertices(heptagonAngle);

    // 1. Update Balls (Gravity & Movement)
    balls.forEach(ball => ball.update());

    // 2. Sub-stepping for Wall Collisions (Better accuracy)
    // We do multiple small steps within one frame to prevent tunneling
    const steps = SUB_STEPS;
    for (let s = 0; s < steps; s++) {
        
        // Calculate current heptagon vertices for this sub-step (linear interpolation for smooth rotation)
        // Note: For simplicity in this demo, we use the final vertices for collision check but scale velocity
        // A perfectly accurate integration would interpolate vertices, but calculating angular velocity impact is tricky.
        // We will use the final angle for wall definition but apply a fraction of the velocity change.
        
        // Let's use the current frame's angle for simplicity in this specific implementation
        // To make it smooth, we'll apply the full collision logic but reduce the time influence
        const currentVertices = getHeptagonVertices(heptagonAngle);
        
        balls.forEach(ball => {
            
            // Check against all 7 walls
            for (let i = 0; i < 7; i++) {
                const p1 = currentVertices[i];
                const p2 = currentVertices[(i + 1) % 7];
                
                const result = distPointToSegment(ball.x, ball.y, p1.x, p1.y, p2.x, p2.y);
                
                // Collision detected
                if (result.dist < ball.r) {
                    
                    // 1. Calculate Wall Normal
                    // Vector along wall
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    
                    // Normal vector (perpendicular to wall, pointing inward)
                    // We need to determine direction. 
                    // Vector from Wall to Ball Center
                    const wx = ball.x - result.projX;
                    const wy = ball.y - result.projY;
                    
                    let nx = wx / result.dist;
                    let ny = wy / result.dist;
                    
                    // Fallback if center is exactly on line
                    if (result.dist === 0) { nx = 0; ny = 1; }

                    // 2. Position Correction (Static Resolution)
                    // Move ball out of wall
                    const overlap = ball.r - result.dist;
                    ball.x += nx * overlap;
                    ball.y += ny * overlap;

                    // 3. Velocity Resolution
                    
                    // Calculate velocity of the wall at the point of impact
                    // V_wall = AngularVel * Radius_vector (perpendicular)
                    // Vector from Center to Impact Point
                    const relX = result.projX - CENTER_X;
                    const relY = result.projY - CENTER_Y;
                    
                    // Tangential velocity of the rotating wall
                    // V_tan_x = -omega * relY
                    // V_tan_y = omega * relX
                    const omega = rotationSpeedRadPerFrame; // Approx per sub-step
                    const wallVx = -omega * relY;
                    const wallVy = omega * relX;

                    // Relative velocity (Ball - Wall)
                    const relVx = ball.vx - wallVx;
                    const relVy = ball.vy - wallVy;

                    // Dot product of relative velocity and normal
                    const velDotNormal = relVx * nx + relVy * ny;

                    // Only bounce if moving towards the wall
                    if (velDotNormal < 0) {
                        
                        // Impulse scalar
                        const j = -(1 + WALL_BOUNCE_DAMPING) * velDotNormal;
                        
                        // Apply impulse along normal
                        const impulseX = j * nx;
                        const impulseY = j * ny;
                        
                        ball.vx += impulseX;
                        ball.vy += impulseY;
                        
                        // Apply Friction (Tangential Force) for Spin
                        // Tangent vector
                        let tx = -ny;
                        let ty = nx;
                        
                        // Dot product of relative velocity and tangent
                        const velDotTangent = relVx * tx + relVy * ty;
                        
                        // Friction impulse (simple model)
                        const frictionCoeff = 0.1; // Tangential friction
                        const fi = -velDotTangent * frictionCoeff;
                        
                        ball.vx += fi * tx;
                        ball.vy += fi * ty;
                        
                        // Transfer angular momentum
                        // Torque = Radius x Force. 
                        // Approximate change in angular velocity
                        const spinTransfer = (velDotTangent * 0.005) + (omega * 0.02);
                        ball.angularVelocity += spinTransfer;
                    }
                }
            }
        });
    }

    // 3. Ball-to-Ball Collision
    // Optimization: Spatial Hashing or Simple Distance Check
    // With only 20 balls, O(N^2) is perfectly fine (< 200 checks).
    
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i];
            const b2 = balls[j];
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            const minDist = b1.r + b2.r;
            
            if (distance < minDist) {
                // Collision detected
                
                // Normal vector
                const nx = dx / distance;
                const ny = dy / distance;
                
                // 1. Position Correction (prevent sticking)
                const overlap = minDist - distance;
                const correctionX = nx * overlap * 0.5;
                const correctionY = ny * overlap * 0.5;
                
                b1.x -= correctionX;
                b1.y -= correctionY;
                b2.x += correctionX;
                b2.y += correctionY;
                
                // 2. Velocity Resolution (1D Elastic Collision along Normal)
                
                // Relative velocity
                const rvx = b2.vx - b1.vx;
                const rvy = b2.vy - b1.vy;
                
                // Velocity along normal
                const velAlongNormal = rvx * nx + rvy * ny;
                
                // Do not resolve if velocities are separating
                if (velAlongNormal > 0) continue;
                
                // Impulse scalar
                let jVal = -(1 + BALL_BOUNCE_DAMPING) * velAlongNormal;
                jVal /= (1 / b1.mass + 1 / b2.mass);
                
                const impulseX = jVal * nx;
                const impulseY = jVal * ny;
                
                b1.vx -= impulseX / b1.mass;
                b1.vy -= impulseY / b1.mass;
                b2.vx += impulseX / b2.mass;
                b2.vy += impulseY / b2.mass;
                
                // Simple friction/spin exchange between balls
                const spinExchange = (b2.angularVelocity - b1.angularVelocity) * 0.05;
                b1.angularVelocity += spinExchange;
                b2.angularVelocity -= spinExchange;
            }
        }
    }
}

/**
 * RENDERING
 */
function drawHeptagon() {
    const vertices = getHeptagonVertices(heptagonAngle);
    
    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    for (let i = 1; i < vertices.length; i++) {
        ctx.lineTo(vertices[i].x, vertices[i].y);
    }
    ctx.closePath();
    
    // Styling
    ctx.lineWidth = 5;
    ctx.strokeStyle = "#2c3e50";
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    ctx.fill();
    ctx.stroke();
    
    // Draw Center Pivot
    ctx.beginPath();
    ctx.arc(CENTER_X, CENTER_Y, 5, 0, Math.PI*2);
    ctx.fillStyle = "#e74c3c";
    ctx.fill();
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    
    // Background Grid (Optional aesthetic)
    ctx.strokeStyle = "#f0f0f0";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<W; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,H); }
    for(let i=0; i<H; i+=50) { ctx.moveTo(0,i); ctx.lineTo(W,i); }
    ctx.stroke();

    drawHeptagon();
    
    balls.forEach(ball => ball.draw(ctx));
}

function gameLoop(timestamp) {
    if (!isPaused) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;

        // Cap dt to prevent explosion on lag
        const safeDt = Math.min(dt, 50); 
        
        updatePhysics(safeDt);
        draw();
    }
    requestAnimationFrame(gameLoop);
}

function resetSimulation() {
    initBalls();
    heptagonAngle = 0;
}

function togglePause() {
    isPaused = !isPaused;
    document.getElementById('pauseBtn').innerText = isPaused ? "Resume" : "Pause";
    document.getElementById('pauseBtn').style.backgroundColor = isPaused ? "#27ae60" : "#f39800";
}

// Start
initBalls();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>