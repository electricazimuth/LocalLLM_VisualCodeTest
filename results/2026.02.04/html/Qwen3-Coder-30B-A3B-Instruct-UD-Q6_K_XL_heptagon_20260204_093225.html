<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in a Spinning Heptagon</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            border: 1px solid #888; 
            background-color: #fff; 
            display: block; 
            margin: 20px auto; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #info {
            text-align: center;
            margin: 10px auto;
            max-width: 600px;
            background-color: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Bouncing Balls in a Spinning Heptagon</h2>
        <p>20 balls with physics simulation: gravity, damping, collisions, and rotation</p>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Physics constants
        const GRAVITY = 0.2;
        const DAMPING = 0.85;
        const FRICTION = 0.99;
        const ROTATION_SPEED = 360 / 5000; // 360 degrees per 5 seconds
        const BALL_RADIUS = 15;
        const HEPTAGON_RADIUS = 250;
        const BALL_COUNT = 20;

        // Ball colors
        const BALL_COLORS = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51', 
            '#ee7948', '#ed6d3d', '#ec6800', '#ec6800', '#ee7800', 
            '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61', 
            '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];

        // Ball class
        class Ball {
            constructor(x, y, radius, color, number) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.radius = radius;
                this.color = color;
                this.number = number;
                this.rotation = 0;
                this.angularVelocity = (Math.random() - 0.5) * 0.1;
            }

            update() {
                // Apply gravity
                this.vy += GRAVITY;
                
                // Apply friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Update rotation
                this.rotation += this.angularVelocity;
                
                // Apply friction to rotation
                this.angularVelocity *= 0.99;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw number
                ctx.fillStyle = '#000';
                ctx.font = 'bold ' + (this.radius * 0.6) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.number.toString(), 0, 0);
                
                ctx.restore();
            }
        }

        // Heptagon class
        class Heptagon {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.rotation = 0;
            }

            update() {
                this.rotation += ROTATION_SPEED;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw heptagon
                ctx.beginPath();
                for (let i = 0; i < 7; i++) {
                    const angle = (i * 2 * Math.PI / 7) - Math.PI/2;
                    const x = this.radius * Math.cos(angle);
                    const y = this.radius * Math.sin(angle);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Get vertices of the heptagon
            getVertices() {
                const vertices = [];
                for (let i = 0; i < 7; i++) {
                    const angle = (i * 2 * Math.PI / 7) - Math.PI/2 + this.rotation;
                    const x = this.x + this.radius * Math.cos(angle);
                    const y = this.y + this.radius * Math.sin(angle);
                    vertices.push({x, y});
                }
                return vertices;
            }
        }

        // Create heptagon
        const heptagon = new Heptagon(W/2, H/2, HEPTAGON_RADIUS);

        // Create balls
        const balls = [];
        for (let i = 0; i < BALL_COUNT; i++) {
            // Position balls in the center initially
            const x = W/2;
            const y = H/2;
            balls.push(new Ball(x, y, BALL_RADIUS, BALL_COLORS[i], i+1));
        }

        // Check if point is inside heptagon
        function isPointInHeptagon(x, y, vertices) {
            let inside = true;
            for (let i = 0; i < vertices.length; i++) {
                const p1 = vertices[i];
                const p2 = vertices[(i + 1) % vertices.length];
                
                // Calculate cross product to determine side of line
                const cross = (p2.x - p1.x) * (y - p1.y) - (p2.y - p1.y) * (x - p1.x);
                if (cross > 0) {
                    inside = false;
                    break;
                }
            }
            return inside;
        }

        // Get distance between two points
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Check collision with heptagon walls
        function checkWallCollision(ball, vertices) {
            // For each edge, check if ball is colliding
            for (let i = 0; i < vertices.length; i++) {
                const p1 = vertices[i];
                const p2 = vertices[(i + 1) % vertices.length];
                
                // Vector from p1 to p2
                const edgeX = p2.x - p1.x;
                const edgeY = p2.y - p1.y;
                
                // Vector from p1 to ball
                const toBallX = ball.x - p1.x;
                const toBallY = ball.y - p1.y;
                
                // Length of edge
                const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
                
                // Normalize edge vector
                const edgeNormX = edgeX / edgeLength;
                const edgeNormY = edgeY / edgeLength;
                
                // Project ball position onto edge
                const projection = toBallX * edgeNormX + toBallY * edgeNormY;
                
                // Clamp projection to edge
                const clampedProjection = Math.max(0, Math.min(edgeLength, projection));
                
                // Closest point on edge to ball
                const closestX = p1.x + clampedProjection * edgeNormX;
                const closestY = p1.y + clampedProjection * edgeNormY;
                
                // Distance from ball to closest point
                const distX = ball.x - closestX;
                const distY = ball.y - closestY;
                const distance = Math.sqrt(distX * distX + distY * distY);
                
                // Check collision
                if (distance < ball.radius) {
                    // Normal vector (perpendicular to edge)
                    const normalX = -edgeNormY;
                    const normalY = edgeNormX;
                    
                    // Ensure normal points toward ball
                    const dot = distX * normalX + distY * normalY;
                    if (dot < 0) {
                        normalX *= -1;
                        normalY *= -1;
                    }
                    
                    // Normalize normal vector
                    const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);
                    const normX = normalX / normalLength;
                    const normY = normalY / normalLength;
                    
                    // Reflect velocity
                    const dotProduct = ball.vx * normX + ball.vy * normY;
                    ball.vx = ball.vx - 2 * dotProduct * normX * DAMPING;
                    ball.vy = ball.vy - 2 * dotProduct * normY * DAMPING;
                    
                    // Move ball outside collision
                    const overlap = ball.radius - distance;
                    ball.x += normX * overlap * 1.1;
                    ball.y += normY * overlap * 1.1;
                    
                    // Apply spin based on collision
                    const spinForce = 0.05;
                    ball.angularVelocity += (Math.random() - 0.5) * spinForce;
                    
                    return true;
                }
            }
            return false;
        }

        // Check collision between two balls
        function checkBallCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ball1.radius + ball2.radius) {
                // Collision detected
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);
                
                // Rotate ball1's velocity
                const vx1 = ball1.vx * cos + ball1.vy * sin;
                const vy1 = ball1.vy * cos - ball1.vx * sin;
                
                // Rotate ball2's velocity
                const vx2 = ball2.vx * cos + ball2.vy * sin;
                const vy2 = ball2.vy * cos - ball2.vx * sin;
                
                // Collision reaction (1D elastic collision)
                const finalVx1 = ((ball1.radius - ball2.radius) * vx1 + 2 * ball2.radius * vx2) / (ball1.radius + ball2.radius);
                const finalVx2 = ((ball2.radius - ball1.radius) * vx2 + 2 * ball1.radius * vx1) / (ball1.radius + ball2.radius);
                
                // Update velocities
                ball1.vx = finalVx1 * cos - vy1 * sin;
                ball1.vy = vy1 * cos + finalVx1 * sin;
                ball2.vx = finalVx2 * cos - vy2 * sin;
                ball2.vy = vy2 * cos + finalVx2 * sin;
                
                // Separate balls to prevent sticking
                const overlap = (ball1.radius + ball2.radius - distance) / 2;
                ball1.x -= overlap * cos;
                ball1.y -= overlap * sin;
                ball2.x += overlap * cos;
                ball2.y += overlap * sin;
                
                // Apply spin based on collision
                const spinForce = 0.03;
                ball1.angularVelocity += (Math.random() - 0.5) * spinForce;
                ball2.angularVelocity += (Math.random() - 0.5) * spinForce;
                
                return true;
            }
            return false;
        }

        // Handle ball-to-ball collisions
        function handleBallCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    checkBallCollision(balls[i], balls[j]);
                }
            }
        }

        // Animation loop
        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);
            
            // Update heptagon
            heptagon.update();
            
            // Get heptagon vertices
            const vertices = heptagon.getVertices();
            
            // Update and check collisions for each ball
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                
                // Update ball position
                ball.update();
                
                // Check wall collisions
                checkWallCollision(ball, vertices);
                
                // Draw ball
                ball.draw();
            }
            
            // Handle ball-to-ball collisions
            handleBallCollisions();
            
            // Draw heptagon
            heptagon.draw();
            
            // Continue animation
            requestAnimationFrame(gameLoop);
        }

        // Start the simulation
        requestAnimationFrame(gameLoop);
    </script>
    <section id="notes">
        <h3>Simulation Notes:</h3>
        <ul>
            <li>20 balls with unique colors and numbers from 1-20</li>
            <li>Spinning heptagon container (360Â° per 5 seconds)</li>
            <li>Physics simulation with gravity, damping, and friction</li>
            <li>Realistic ball-to-wall and ball-to-ball collisions</li>
            <li>Balls rotate based on collisions and movement</li>
            <li>Collision response prevents overlap and sticking</li>
            <li>Optimized collision detection for performance</li>
        </ul>
    </section>
</body>
</html>