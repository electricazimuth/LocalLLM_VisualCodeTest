<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Ray‑Marching Psychedelic Metaballs</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;}
  canvas{display:block;width:100%;height:100%;}
</style>
</head>
<body>
<canvas id="glCanvas"></canvas>

<!-- ------------------------------------------------------------------ -->
<!-- Vertex shader – simple full‑screen quad                              -->
<script id="vs" type="x-shader/x-vertex">
#version 300 es
in vec2 a_position;
out vec2 v_uv;
void main() {
    v_uv = a_position * 0.5 + 0.5;      // 0..1
    gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>

<!-- ------------------------------------------------------------------ -->
<!-- Fragment shader – ray‑marching with metaballs                      -->
<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;

in vec2 v_uv;
out vec4 outColor;

uniform vec2 u_resolution;
uniform float u_time;

// -----------------------------------------------------
// Utility functions
// -----------------------------------------------------
float sdSphere(vec3 p, vec3 c, float r) {
    return length(p - c) - r;
}

// Smooth minimum (soft‑union)
float smin(float a, float b, float k) {
    return -log(exp(-k*a) + exp(-k*b)) / k;
}

// HSV → RGB
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz)*6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// -----------------------------------------------------
// Scene definition – 5 animated metaballs
// -----------------------------------------------------
float map(vec3 p) {
    // animated positions
    vec3 pos0 = vec3(sin(u_time)*2.0, cos(u_time)*2.0, sin(u_time*0.5)*2.0);
    vec3 pos1 = vec3(cos(u_time*0.7)*2.0, sin(u_time*1.3)*2.0, cos(u_time)*2.0);
    vec3 pos2 = vec3(sin(u_time*1.1)*2.0, cos(u_time*0.9)*2.0, sin(u_time*1.5)*2.0);
    vec3 pos3 = vec3(cos(u_time*1.7)*2.0, sin(u_time*0.6)*2.0, cos(u_time*1.4)*2.0);
    vec3 pos4 = vec3(sin(u_time*0.4)*2.0, cos(u_time*1.8)*2.0, sin(u_time*1.2)*2.0);

    // animated radii
    float r0 = 0.8 + 0.2*sin(u_time*0.5);
    float r1 = 0.8 + 0.2*cos(u_time*0.6);
    float r2 = 0.8 + 0.2*sin(u_time*0.7);
    float r3 = 0.8 + 0.2*cos(u_time*0.8);
    float r4 = 0.8 + 0.2*sin(u_time*0.9);

    float d0 = sdSphere(p, pos0, r0);
    float d1 = sdSphere(p, pos1, r1);
    float d2 = sdSphere(p, pos2, r2);
    float d3 = sdSphere(p, pos3, r3);
    float d4 = sdSphere(p, pos4, r4);

    float k = 8.0; // smoothness factor
    float d01 = smin(d0, d1, k);
    float d012 = smin(d01, d2, k);
    float d0123 = smin(d012, d3, k);
    float d01234 = smin(d0123, d4, k);
    return d01234;
}

// -----------------------------------------------------
// Normal estimation
// -----------------------------------------------------
vec3 calcNormal(vec3 p) {
    const float eps = 0.001;
    float dx = map(p + vec3(eps,0,0)) - map(p - vec3(eps,0,0));
    float dy = map(p + vec3(0,eps,0)) - map(p - vec3(0,eps,0));
    float dz = map(p + vec3(0,0,eps)) - map(p - vec3(0,0,eps));
    return normalize(vec3(dx,dy,dz));
}

// -----------------------------------------------------
// Main fragment shader
// -----------------------------------------------------
void main() {
    // Normalised pixel coordinates (from -1 to 1)
    vec2 uv = v_uv * 2.0 - 1.0;
    uv.x *= u_resolution.x / u_resolution.y;

    // Camera setup
    vec3 camPos = vec3(0.0, 0.0, 5.0);
    vec3 rayDir = normalize(vec3(uv, -1.0));

    // Ray marching
    const int MAX_STEPS = 128;
    const float EPSILON = 0.001;
    const float MAX_DIST = 100.0;
    float t = 0.0;
    vec3 pos;
    int i;
    for(i = 0; i < MAX_STEPS; i++) {
        pos = camPos + rayDir * t;
        float dist = map(pos);
        if(dist < EPSILON) break;
        t += dist;
        if(t > MAX_DIST) break;
    }

    // If nothing hit – background
    if(i == MAX_STEPS || t > MAX_DIST) {
        outColor = vec4(0.0);
        return;
    }

    // Surface shading
    vec3 normal = calcNormal(pos);
    vec3 lightDir = normalize(vec3(0.5, 0.5, -1.0));

    // Basic lighting
    float diff = max(dot(normal, lightDir), 0.0);
    float amb = 0.2;
    float spec = pow(max(dot(reflect(-lightDir, normal), -rayDir), 0.0), 32.0);

    // Color palette – evolving hue
    float hue = mod(0.1 * t + 0.5 * sin(u_time), 1.0);
    vec3 baseColor = hsv2rgb(vec3(hue, 0.8, 0.9));

    vec3 color = baseColor * (amb + diff) + 0.3 * spec;

    // Simple fog
    float fog = exp(-length(pos - camPos)*0.05);
    color = mix(vec3(0.0), color, fog);

    outColor = vec4(color, 1.0);
}
</script>

<!-- ------------------------------------------------------------------ -->
<!-- JavaScript – WebGL 2 setup, animation loop                           -->
<script>
(() => {
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) { alert('WebGL 2 not available'); return; }

    // -------------------------------------------------------------
    // Helper functions
    // -------------------------------------------------------------
    function loadShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(vsSource, fsSource) {
        const program = gl.createProgram();
        const vs = loadShader(gl.VERTEX_SHADER, vsSource);
        const fs = loadShader(gl.FRAGMENT_SHADER, fsSource);
        if (!vs || !fs) return null;
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    // -------------------------------------------------------------
    // Compile shaders
    // -------------------------------------------------------------
    const vsSource = document.getElementById('vs').text;
    const fsSource = document.getElementById('fs').text;
    const program = createProgram(vsSource, fsSource);
    if (!program) return;

    gl.useProgram(program);

    // -------------------------------------------------------------
    // Attributes
    // -------------------------------------------------------------
    const aPosLoc = gl.getAttribLocation(program, 'a_position');
    const quadVerts = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
    ]);
    const vao = gl.createVertexArray();
    const vbo = gl.createBuffer();
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(null);

    // -------------------------------------------------------------
    // Uniform locations
    // -------------------------------------------------------------
    const uTimeLoc = gl.getUniformLocation(program, 'u_time');
    const uResLoc  = gl.getUniformLocation(program, 'u_resolution');

    // -------------------------------------------------------------
    // Resize handling
    // -------------------------------------------------------------
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(uResLoc, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // -------------------------------------------------------------
    // Animation loop
    // -------------------------------------------------------------
    let startTime = performance.now();
    function render() {
        const currentTime = performance.now();
        const elapsed = (currentTime - startTime) / 1000.0; // seconds

        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);
        gl.uniform1f(uTimeLoc, elapsed);

        gl.bindVertexArray(vao);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindVertexArray(null);

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
})();
</script>

<!-- ------------------------------------------------------------------ -->
<!-- Notes – implementation choices and future improvements             -->
<section id="notes" style="display:none;">
    <h2>Developer Notes</h2>
    <ul>
        <li><strong>Ray‑marching</strong> uses a simple perspective camera.  The ray direction is
            derived from the normalized pixel coordinates.  The camera is positioned at
            (0,0,5) looking towards the origin.</li>
        <li><strong>Metaballs</strong> are generated directly in the shader as animated
            spheres.  Their positions and radii are functions of time, creating
            continuous motion without any JavaScript state.</li>
        <li><strong>Smooth minimum (smin)</strong> implements a soft union of the
            individual sphere SDFs, yielding the classic “blobby” appearance.  The
            smoothness factor k controls how sharply the blobs merge.</li>
        <li><strong>Coloring</strong> uses HSV to RGB conversion.  The hue is a function
            of both the ray distance and the global time, giving a constantly
            shifting psychedelic palette.</li>
        <li><strong>Lighting</strong> is very light‑weight: a single directional light,
            ambient term, and a simple specular highlight.  Fog is added to
            soften the depth and add atmosphere.</li>
        <li><strong>Performance</strong> is kept low: 128 marching steps, a single
            SDF evaluation per step, and no high‑frequency noise.  The shader
            runs comfortably at 60 fps on modern browsers.</li>
        <li><strong>Future extensions</strong> could add:
            <ul>
                <li>Perlin/Simplex noise to modulate radii or positions.</li>
                <li>Ambient occlusion approximation.</li>
                <li>Multiple render passes for bloom or depth‑of‑field.</li>
                <li>User interaction (e.g., mouse to influence a metaball).</li>
            </ul>
        </li>
    </ul>
</section>
<!-- ------------------------------------------------------------------ -->
</body>
</html>