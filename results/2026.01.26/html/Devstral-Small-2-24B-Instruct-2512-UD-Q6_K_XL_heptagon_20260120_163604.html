<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in Spinning Heptagon</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Constants
        const GRAVITY = 0.2;
        const DAMPING = 0.95;
        const BALL_RADIUS = 15;
        const HEPTAGON_SIZE = 250;
        const SPIN_SPEED = 360 / 500000; // 360 degrees per 5 seconds
        const COLORS = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51',
            '#ee7948', '#ed6d3d', '#ec6800', '#ec6800', '#ee7800',
            '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61',
            '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];

        // Ball class
        class Ball {
            constructor(id, x, y, color) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = BALL_RADIUS;
                this.color = color;
                this.angle = 0;
                this.angularVelocity = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY;
                this.angle += this.angularVelocity;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw number
                ctx.fillStyle = 'black';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id.toString(), 0, 0);
                ctx.restore();
            }
        }

        // Heptagon class
        class Heptagon {
            constructor(centerX, centerY, size) {
                this.centerX = centerX;
                this.centerY = centerY;
                this.size = size;
                this.angle = 0;
            }

            getPoints() {
                const points = [];
                for (let i = 0; i < 7; i++) {
                    const angle = this.angle + (i * 2 * Math.PI / 7);
                    const x = this.centerX + this.size * Math.cos(angle);
                    const y = this.centerY + this.size * Math.sin(angle);
                    points.push({x, y});
                }
                return points;
            }

            draw(ctx) {
                const points = this.getPoints();
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < 7; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            checkCollision(ball) {
                const points = this.getPoints();
                let minDistance = Infinity;
                let closestPoint = null;

                // Find the closest point on the heptagon to the ball
                for (let i = 0; i < 7; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % 7];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    const t = ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / (len * len);
                    const tClamped = Math.max(0, Math.min(1, t));

                    const closestX = p1.x + tClamped * dx;
                    const closestY = p1.y + tClamped * dy;

                    const distance = Math.sqrt((ball.x - closestX) ** 2 + (ball.y - closestY) ** 2);

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = {x: closestX, y: closestY};
                    }
                }

                if (minDistance < ball.radius) {
                    // Collision detected
                    const normalX = (ball.x - closestPoint.x) / minDistance;
                    const normalY = (ball.y - closestPoint.y) / minDistance;

                    // Reflect velocity
                    const dotProduct = ball.vx * normalX + ball.vy * normalY;
                    ball.vx = ball.vx - 2 * dotProduct * normalX * DAMPING;
                    ball.vy = ball.vy - 2 * dotProduct * normalY * DAMPING;

                    // Apply angular velocity based on collision
                    const tangentX = -normalY;
                    const tangentY = normalX;
                    const tangentVelocity = ball.vx * tangentX + ball.vy * tangentY;
                    ball.angularVelocity = tangentVelocity * 0.1;

                    // Move ball outside the heptagon
                    ball.x += normalX * (ball.radius - minDistance);
                    ball.y += normalY * (ball.radius - minDistance);

                    return true;
                }

                return false;
            }
        }

        // Game state
        let balls = [];
        let heptagon;
        let lastTime = 0;

        // Initialize game
        function init() {
            const centerX = W / 2;
            const centerY = H / 2;

            // Create heptagon
            heptagon = new Heptagon(centerX, centerY, HEPTAGON_SIZE);

            // Create balls
            for (let i = 1; i <= 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * HEPTAGON_SIZE * 0.3;
                const x = centerX + distance * Math.cos(angle);
                const y = centerY + distance * Math.sin(angle);

                balls.push(new Ball(i, x, y, COLORS[i - 1]));
            }

            // Start animation loop
            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update(deltaTime) {
            // Update heptagon rotation
            heptagon.angle += SPIN_SPEED * deltaTime;

            // Update balls
            for (const ball of balls) {
                ball.update();

                // Wall collision
                heptagon.checkCollision(ball);

                // Boundary checks (just in case)
                if (ball.x < ball.radius) {
                    ball.x = ball.radius;
                    ball.vx = -ball.vx * DAMPING;
                }
                if (ball.x > W - ball.radius) {
                    ball.x = W - ball.radius;
                    ball.vx = -ball.vx * DAMPING;
                }
                if (ball.y < ball.radius) {
                    ball.y = ball.radius;
                    ball.vy = -ball.vy * DAMPING;
                }
                if (ball.y > H - ball.radius) {
                    ball.y = H - ball.radius;
                    ball.vy = -ball.vy * DAMPING;
                }
            }

            // Ball-ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];

                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < ball1.radius + ball2.radius) {
                        // Collision detected
                        const angle = Math.atan2(dy, dx);
                        const sine = Math.sin(angle);
                        const cosine = Math.cos(angle);

                        // Rotate velocities into collision space
                        const x1 = ball1.vx * cosine + ball1.vy * sine;
                        const y1 = ball1.vy * cosine - ball1.vx * sine;
                        const x2 = ball2.vx * cosine + ball2.vy * sine;
                        const y2 = ball2.vy * cosine - ball2.vx * sine;

                        // Apply 1D collision physics
                        const m1 = 1;
                        const m2 = 1;
                        const p1 = (x1 * (m1 - m2) + 2 * m2 * x2) / (m1 + m2);
                        const p2 = (x2 * (m2 - m1) + 2 * m1 * x1) / (m1 + m2);

                        // Rotate velocities back into original space
                        ball1.vx = p1 * cosine - y1 * sine;
                        ball1.vy = p1 * sine + y1 * cosine;
                        ball2.vx = p2 * cosine - y2 * sine;
                        ball2.vy = p2 * sine + y2 * cosine;

                        // Apply damping
                        ball1.vx *= DAMPING;
                        ball1.vy *= DAMPING;
                        ball2.vx *= DAMPING;
                        ball2.vy *= DAMPING;

                        // Move balls apart to prevent sticking
                        const overlap = ball1.radius + ball2.radius - distance;
                        ball1.x -= overlap * 0.5 * cosine;
                        ball1.y -= overlap * 0.5 * sine;
                        ball2.x += overlap * 0.5 * cosine;
                        ball2.y += overlap * 0.5 * sine;
                    }
                }
            }
        }

        // Draw game
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);

            // Draw heptagon
            heptagon.draw(ctx);

            // Draw balls
            for (const ball of balls) {
                ball.draw(ctx);
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        init();
    </script>
    <section id="notes">
        <h3>Implementation Notes:</h3>
        <ul>
            <li>Physics simulation includes gravity, damping, and realistic bouncing</li>
            <li>Ball-ball collisions use proper 2D physics with rotation</li>
            <li>Heptagon spins at 360 degrees per 5 seconds</li>
            <li>Each ball has a unique number (1-20) that rotates with the ball</li>
            <li>Collision detection with heptagon edges is precise</li>
            <li>No external libraries used - pure vanilla JavaScript</li>
        </ul>
    </section>
</body>
</html>