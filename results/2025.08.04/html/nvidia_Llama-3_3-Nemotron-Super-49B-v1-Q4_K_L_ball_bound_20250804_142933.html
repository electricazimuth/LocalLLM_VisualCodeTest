<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
        #notes { font-family: monospace; margin: 20px auto; width: 80%; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Constants
        const GRAVITY = 0.1;
        const DAMPING_FACTOR = 0.9;
        const BALL_COUNT = 50;
        const MAX_RADIUS = 20;
        const MIN_RADIUS = 5;

        // Ball Class
        class Ball {
            constructor(x, y, vx, vy, r, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.r = r;
                this.color = color;
                this.mass = Math.PI * r ** 2; // Mass proportional to area
            }

            // Update position based on velocity
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY; // Apply Gravity
            }

            // Draw the ball
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Initialize Balls with random properties
        let balls = [];
        function initBalls() {
            for (let i = 0; i < BALL_COUNT; i++) {
                let r = Math.random() * (MAX_RADIUS - MIN_RADIUS) + MIN_RADIUS;
                let color = `rgb(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255})`;
                // Attempt to prevent initial overlap (simplified, not guaranteed)
                let x, y;
                do {
                    x = Math.random() * (W - 2*r) + r;
                    y = Math.random() * (H - 2*r) + r;
                } while (balls.some(b => distance(b, {x, y}) < b.r + r));
                
                balls.push(new Ball(x, y, 
                                   Math.random() * 2 - 1, // Random initial vx
                                   Math.random() * -2,   // Initial vy for some upward motion
                                   r, 
                                   color));
            }
        }

        // Distance between two points
        function distance(a, b) {
            return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
        }

        // Simplified Spatial Partitioning for Optimization (Grid)
        const GRID_SIZE = 100;
        let grid = {};
        function updateGrid() {
            grid = {}; // Reset grid
            for (let ball of balls) {
                const xGrid = Math.floor(ball.x / GRID_SIZE);
                const yGrid = Math.floor(ball.y / GRID_SIZE);
                if (!grid[`${xGrid},${yGrid}`]) grid[`${xGrid},${yGrid}`] = [];
                grid[`${xGrid},${yGrid}`].push(ball);
            }
        }

        function getNearbyBalls(ball) {
            const xGrid = Math.floor(ball.x / GRID_SIZE);
            const yGrid = Math.floor(ball.y / GRID_SIZE);
            const nearbyCells = [
                `${xGrid-1},${yGrid-1}`, `${xGrid},${yGrid-1}`, `${xGrid+1},${yGrid-1}`,
                `${xGrid-1},${yGrid}`,   `${xGrid},${yGrid}`,   `${xGrid+1},${yGrid}`,
                `${xGrid-1},${yGrid+1}`, `${xGrid},${yGrid+1}`, `${xGrid+1},${yGrid+1}`,
            ];
            return [...new Set(nearbyCells.flatMap(cell => grid[cell] || []))].filter(b => b !== ball);
        }

        // Handle Wall Collisions
        function handleWallCollisions(ball) {
            if (ball.x - ball.r < 0 || ball.x + ball.r > W) {
                ball.vx = -ball.vx * DAMPING_FACTOR;
                // Correct position to prevent embedding
                ball.x = Math.max(ball.r, Math.min(W - ball.r, ball.x));
            }
            if (ball.y - ball.r < 0 || ball.y + ball.r > H) {
                ball.vy = -ball.vy * DAMPING_FACTOR;
                ball.y = Math.max(ball.r, Math.min(H - ball.r, ball.y));
            }
        }

        // Handle Ball-to-Ball Collisions
        function handleBallCollisions(ball, other) {
            const distanceBetween = distance(ball, other);
            if (distanceBetween <= ball.r + other.r) {
                // Simplified Response: Swap velocities for a basic interaction
                // **Note:** This is a significant simplification. Realistic elastic collision would involve more complex vector math.
                [ball.vx, other.vx] = [other.vx, ball.vx];
                [ball.vy, other.vy] = [other.vy, ball.vy];
                
                // Attempt to separate balls to prevent sticking
                const overlap = (ball.r + other.r) - distanceBetween;
                const dx = other.x - ball.x;
                const dy = other.y - ball.y;
                const direction = Math.atan2(dy, dx);
                ball.x -= Math.cos(direction) * overlap / 2;
                ball.y -= Math.sin(direction) * overlap / 2;
                other.x += Math.cos(direction) * overlap / 2;
                other.y += Math.sin(direction) * overlap / 2;
            }
        }

        // Main Game Loop
        function gameLoop(timestamp) {
            ctx.clearRect(0, 0, W, H);

            // Update Grid for Spatial Partitioning
            updateGrid();

            for (let ball of balls) {
                ball.update();
                handleWallCollisions(ball);

                // Efficiently check collisions with nearby balls only
                for (let other of getNearbyBalls(ball)) {
                    handleBallCollisions(ball, other);
                }
            }

            for (let ball of balls) {
                ball.draw();
            }

            requestAnimationFrame(gameLoop);
        }

        initBalls();
        requestAnimationFrame(gameLoop);
    </script>
    <section id="notes">
        <h2>Implementation Notes</h2>
        <ul>
            <li><strong>Spatial Partitioning (Grid):</strong> Implemented to reduce collision checks from O(n^2) to approximately O(n) on average, significantly improving performance with 50+ balls.</li>
            <li><strong>Ball-to-Ball Collision Response:</strong> Simplified by swapping velocities. For a more realistic simulation, consider implementing elastic collision response using vector math and momentum conservation principles.</li>
            <li><strong>Initial Placement:</strong> A simple loop attempts to prevent initial overlaps but does not guarantee complete success due to randomness and simplicity.</li>
            <li><strong>Mass Calculation:</strong> Proportional to the area of the ball (Ï€r^2) for a basic representation. Actual mass properties could be constant or based on other factors.</li>
            <li><strong>Optimization:</strong> Besides spatial partitioning, using `requestAnimationFrame` ensures a smooth, frame-rate adapted animation loop.</li>
        </ul>
    </section>
</body>
</html>