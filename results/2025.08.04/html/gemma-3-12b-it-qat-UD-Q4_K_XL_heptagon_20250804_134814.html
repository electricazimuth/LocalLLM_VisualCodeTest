<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        const ballColors = [
            "#f8b862", "#f6ad49", "#f39800", "#f08300", "#ec6d51",
            "#ee7948", "#ed6d3d", "#ec6800", "#ec6800", "#ee7800",
            "#eb6238", "#ea5506", "#ea5506", "#eb6101", "#e49e61",
            "#e45e32", "#e17b34", "#dd7a56", "#db8449", "#d66a35"
        ];

        const numBalls = 20;
        const balls = [];
        const radius = 20;
        const gravity = 0.5;
        const damping = 0.8;
        const rotationSpeed = 0.02; // Radians per frame (360 degrees per 5 seconds)

        // Heptagon vertices (centered at canvas center)
        const heptagonVertices = [];
        for (let i = 0; i < 7; i++) {
            const angle = (2 * Math.PI / 7) * i;
            const x = Math.cos(angle) * (W / 2);
            const y = Math.sin(angle) * (H / 2);
            heptagonVertices.push({ x, y });
        }

        function init() {
            for (let i = 0; i < numBalls; i++) {
                balls.push({
                    x: W / 2,
                    y: H / 2,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    r: radius,
                    color: ballColors[i],
                    spin: (Math.random() - 0.5) * 5 // Initial spin
                });
            }
        }

        function update() {
            // Apply gravity
            for (let i = 0; i < numBalls; i++) {
                balls[i].vy += gravity;
            }

            // Update positions
            for (let i = 0; i < numBalls; i++) {
                balls[i].x += balls[i].vx;
                balls[i].y += balls[i].vy;

                // Wall collision
                if (balls[i].x - balls[i].r < 0 || balls[i].x + balls[i].r > W) {
                    balls[i].vx = -balls[i].vx * damping;
                }
                if (balls[i].y - balls[i].r < 0 || balls[i].y + balls[i].r > H) {
                    balls[i].vy = -balls[i].vy * damping;
                }

                // Heptagon collision
                if (isInsideHeptagon(balls[i].x, balls[i].y)) {
                    // Simple bounce off heptagon - improve this for more realistic behavior
                    // For now, just reverse velocity
                    const normal = getNormal(balls[i].x, balls[i].y, heptagonVertices);
                    balls[i].vx -= normal.x * damping * 2;
                    balls[i].vy -= normal.y * damping * 2;
                }

                // Ball-to-ball collision
                for (let j = i + 1; j < numBalls; j++) {
                    if (checkCollision(balls[i], balls[j])) {
                        resolveCollision(balls[i], balls[j]);
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            drawHeptagon();

            for (let i = 0; i < numBalls; i++) {
                ctx.beginPath();
                ctx.arc(balls[i].x, balls[i].y, balls[i].r, 0, 2 * Math.PI);
                ctx.fillStyle = balls[i].color;
                ctx.fill();
                ctx.closePath();

                // Draw spin indicator
                ctx.save();
                ctx.translate(balls[i].x, balls[i].y);
                ctx.rotate(balls[i].spin);
                ctx.fillStyle = "black";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText(i + 1, 0, 0);
                ctx.restore();
            }
        }

        function drawHeptagon() {
            ctx.beginPath();
            for (let i = 0; i < 7; i++) {
                const vertex = heptagonVertices[i];
                if (i === 0) {
                    ctx.moveTo(vertex.x, vertex.y);
                } else {
                    ctx.lineTo(vertex.x, vertex.y);
                }
            }
            ctx.closePath();
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function checkCollision(ball1, ball2) {
            const dx = ball1.x - ball2.x;
            const dy = ball1.y - ball2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= ball1.r + ball2.r;
        }

        function resolveCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const nx = dx / distance;
            const ny = dy / distance;

            const relativeVelocityX = ball1.vx - ball2.vx;
            const relativeVelocityY = ball1.vy - ball2.vy;

            const impulseX = (relativeVelocityX * nx + relativeVelocityY * ny) / 2;
            const impulseY = (relativeVelocityX * ny - relativeVelocityY * nx) / 2;

            ball1.vx -= impulseX * nx;
            ball1.vy -= impulseY * ny;
            ball2.vx += impulseX * nx;
            ball2.vy += impulseY * ny;
        }

        function isInsideHeptagon(x, y) {
            let wn = 0;
            for (let i = 0; i < 7; i++) {
                const p1 = heptagonVertices[i];
                const p2 = heptagonVertices[(i + 1) % 7];

                if (p1.y <= y) {
                    if (p2.y > y && isLeft(p1, p2, { x, y }) > 0) {
                        wn++;
                    }
                } else {
                    if (p2.y <= y && isLeft(p1, p2, { x, y }) < 0) {
                        wn--;
                    }
                }
            }
            return wn !== 0;
        }

        function isLeft(p1, p2, p3) {
            return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
        }

        function getNormal(x, y, vertices) {
            let closestVertex = null;
            let closestDistance = Infinity;

            for (let i = 0; i < vertices.length; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertices.length];

                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / length;
                const ny = dy / length;

                const distance = Math.abs((v2.x - v1.x) * (y - v1.y) - (v2.y - v1.y) * (x - v1.x)) / length;

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestVertex = { x: nx, y: ny };
                }
            }

            return closestVertex;
        }


        init();

        function gameLoop(timestamp) {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);

        // Add any initial setup or event listeners here

    </script>
    <section id="notes">
        <p>This code simulates 20 bouncing balls within a spinning heptagon. Gravity, damping, ball-ball collisions, and heptagon collisions are implemented.  The balls are numbered for visual indication of rotation.</p>
        <p>Optimization: The collision detection is still O(n^2). A spatial partitioning technique (e.g., grid) could significantly improve performance for a larger number of balls. The heptagon collision response is a basic reversal of velocity; more sophisticated handling could improve realism.</p>
        <p>The heptagon is drawn using its vertices. The `isInsideHeptagon` function uses the winding number algorithm to determine if a point is inside the polygon.</p>
    </section>
</body>
</html>