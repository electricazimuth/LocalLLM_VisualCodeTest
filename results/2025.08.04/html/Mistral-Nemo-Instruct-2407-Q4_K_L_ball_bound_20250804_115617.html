<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        const GRAVITY = 0.5;
        const DAMPING = 0.95;
        const BALL_RADII = [5, 8, 10];
        const NUM_BALLS = 50;
        const GRID_SIZE = 20;

        class Ball {
            constructor(x, y, r, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            update() {
                this.y += this.vy;
                this.x += this.vx;
            }

            collidesWith(other) {
                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                return dist <= this.r + other.r;
            }

            resolveCollision(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.hypot(dx, dy);
                const normalX = dx / dist;
                const normalY = dy / dist;

                const relativeVelocity = other.vx - this.vx;

                const impulse = (2 * relativeVelocity) / (this.r + other.r);
                this.vx += impulse * normalX;
                this.vy += impulse * normalY;

                other.vx -= impulse * normalX;
                other.vy -= impulse * normalY;
            }
        }

        const balls = Array.from({ length: NUM_BALLS }, () => {
            const r = BALL_RADII[Math.floor(Math.random() * BALL_RADII.length)];
            const x = r + Math.random() * (W - 2 * r);
            const y = r + Math.random() * (H - 2 * r);
            const vx = (Math.random() - 0.5) * 5;
            const vy = (Math.random() - 0.5) * 5;
            const color = `rgb(${Math.floor(255 * Math.random())}, ${Math.floor(255 * Math.random())}, ${Math.floor(255 * Math.random())})`;
            return new Ball(x, y, r, vx, vy, color);
        });

        const grid = new Array(Math.ceil(W / GRID_SIZE)).fill().map(() => new Array(Math.ceil(H / GRID_SIZE)).fill().map(() => []));

        function gameLoop(timestamp) {
            ctx.clearRect(0, 0, W, H);

            balls.forEach(ball => {
                ball.update();

                // Wall collisions
                if (ball.x - ball.r < 0 || ball.x + ball.r > W) {
                    ball.vx = -ball.vx * DAMPING;
                    ball.x = Math.max(ball.r, Math.min(ball.x, W - ball.r));
                }
                if (ball.y - ball.r < 0 || ball.y + ball.r > H) {
                    ball.vy = -ball.vy * DAMPING;
                    ball.y = Math.max(ball.r, Math.min(ball.y, H - ball.r));
                }

                // Update grid position
                const [gridX, gridY] = [Math.floor(ball.x / GRID_SIZE), Math.floor(ball.y / GRID_SIZE)];
                grid[gridX][gridY].push(ball);
            });

            // Ball-to-ball collisions
            grid.forEach(row => {
                row.forEach(cells => {
                    cells.forEach(ball1 => {
                        const otherBalls = cells.filter(ball2 => ball2 !== ball1);
                        otherBalls.forEach(other => {
                            if (ball1.collidesWith(other)) {
                                ball1.resolveCollision(other);
                            }
                        });
                    });
                });
            });

            balls.forEach(ball => ball.draw(ctx));

            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);

    </script>
    <section id="notes">
        <!-- Notes go here -->
    </section>
</body>
</html>