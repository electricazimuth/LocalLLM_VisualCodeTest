<!DOCTYPE html>
<html>
<head>
    <title>Ray Marching Metaballs</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        // --- Standard WebGL Boilerplate ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // --- Shaders ---
        const vertexShaderSource = `
            #version 300 es
            in vec2 aPosition;
            out vec2 vUv;

            void main() {
                gl_Position = vec4(aPosition.x, aPosition.y, 0.0, 1.0);
                vUv = aPosition;
            }
        `;

        const fragmentShaderSource = `
            #version 300 es
            precision highp float;

            in vec2 vUv;
            out vec4 fragColor;

            uniform float time;
            uniform vec2 resolution;

            // Metaball parameters (up to 8)
            uniform vec3 metaballPositions[8];
            uniform float metaballRadii[8];

            // SDF for a sphere
            float sphereSDF(vec3 p, float r) {
                return length(p) - r;
            }

            // Smooth minimum function
            float smin(float a, float b, float k) {
                return -log(exp(-k * a) + exp(-k * b)) / k;
            }

            // Combined SDF for multiple metaballs
            float sceneSDF(vec3 p) {
                float dist = 1000.0;
                for (int i = 0; i < 8; ++i) {
                    dist = min(dist, sphereSDF(p - metaballPositions[i], metaballRadii[i]));
                }
                return dist;
            }

            // Ray marching function
            float rayMarch(vec3 origin, vec3 direction) {
                float dist = 0.0;
                for (int i = 0; i < 128; ++i) {
                    vec3 p = origin + direction * dist;
                    float s = sceneSDF(p);
                    if (s < 0.001) {
                        return dist;
                    }
                    dist += s;
                    if (dist > 100.0) {
                        return 100.0;
                    }
                }
                return 100.0;
            }

            // Calculate normal (approximate)
            vec3 calculateNormal(vec3 p) {
                const float epsilon = 0.001;
                vec3 e = vec3(epsilon, 0.0, 0.0);
                return normalize(vec3(
                    sceneSDF(p + e.x) - sceneSDF(p - e.x),
                    sceneSDF(p + e.y) - sceneSDF(p - e.y),
                    sceneSDF(p + e.z) - sceneSDF(p - e.z)
                ));
            }

            // Coloring function
            vec3 getSurfaceColor(vec3 p, vec3 normal) {
                // Psychedelic color shifting
                float hue = fract(time * 0.3 + dot(p.xy, vec2(12.9898, 78.233)));
                vec3 color = hsv2rgb(hue, 1.0, 1.0);

                // Basic lighting
                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
                float diff = max(dot(normal, lightDir), 0.0);
                color *= diff;

                return color;
            }

            // Helper function to convert HSV to RGB
            vec3 hsv2rgb(float h, float s, float v) {
                int i = int(h * 6.0);
                float f = h * 6.0 - float(i);
                float p = v * (1.0 - s);
                float q = v * (1.0 - f * s);
                float t = v * (1.0 - (1.0 - f) * s);
                vec3 color = vec3(0.0);

                if (i == 0) color = vec3(v, t, p);
                else if (i == 1) color = vec3(q, v, p);
                else if (i == 2) color = vec3(p, v, t);
                else if (i == 3) color = vec3(p, q, v);
                else if (i == 4) color = vec3(t, p, v);
                else if (i == 5) color = vec3(v, p, q);

                return color;
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                uv.x *= resolution.x / resolution.y;

                vec3 origin = vec3(0.0, 0.0, 0.0);
                vec3 direction = normalize(vec3(uv, -1.0));

                float dist = rayMarch(origin, direction);

                if (dist < 100.0) {
                    vec3 p = origin + direction * dist;
                    vec3 normal = calculateNormal(p);
                    fragColor = vec4(getSurfaceColor(p, normal), 1.0);
                } else {
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            }
        `;

        // --- Compile Shaders ---
        const vertexShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        // --- Create Program ---
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // --- Attributes and Uniforms ---
        const positionAttribute = gl.getAttribLocation(program, 'aPosition');
        const timeUniform = gl.getUniformLocation(program, 'time');
        const resolutionUniform = gl.getUniformLocation(program, 'resolution');

        // Metaball positions and radii uniforms
        const metaballPositionsUniform = [];
        const metaballRadiiUniform = [];
        for (let i = 0; i < 8; ++i) {
            metaballPositionsUniform[i] = gl.getUniformLocation(program, 'metaballPositions[' + i + ']');
            metaballRadiiUniform[i] = gl.getUniformLocation(program, 'metaballRadii[' + i + ']');
        }

        // --- Vertex Data ---
        const vertices = [
            -1.0, -1.0,
            1.0, -1.0,
            -1.0, 1.0,
            1.0, 1.0
        ];

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW_ARRAY);
        gl.enableVertexAttribArray(positionAttribute);
        gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);

        // --- Rendering Loop ---
        let startTime = performance.now();
        function render() {
            const now = performance.now();
            const deltaTime = (now - startTime) / 1000.0;
            startTime = now;

            gl.uniform1f(timeUniform, deltaTime);
            gl.uniform2f(resolutionUniform, width, height);

            // Update metaball positions and radii (dynamic)
            for (let i = 0; i < 8; ++i) {
                const pos = vec3(
                    Math.sin(time * 0.1 + i * 0.5),
                    Math.cos(time * 0.2 + i * 0.3),
                    Math.sin(time * 0.3 + i * 0.2)
                );
                const radius = 0.2 + Math.sin(time * 0.4 + i * 0.1) * 0.1;
                gl.uniform3f(metaballPositionsUniform[i], pos.x, pos.y, pos.z);
                gl.uniform1f(metaballRadiiUniform[i], radius);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        render();

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);
            gl.uniform2f(resolutionUniform, width, height);
        });
    </script>
</body>
</html>