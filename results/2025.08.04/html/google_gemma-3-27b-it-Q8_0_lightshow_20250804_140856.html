<!DOCTYPE html>
<html>
<head>
    <title>Ray Marching Metaballs</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        // --- Standard WebGL Boilerplate ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // --- Shaders ---
        const vertexShaderSource = `
            void main() {
                gl_Position = vec4(1.0, 1.0, 0.0, 1.0); // Fullscreen quad
                gl_Position.x *= 2.0;
                gl_Position.y *= 2.0;
                gl_Position.y -= 1.0;
            }
        `;

        const fragmentShaderSource = `
            #version 0
            precision highp float;

            uniform float time;
            uniform vec2 resolution;

            // Metaball parameters
            uniform float metaballCount;
            uniform vec3 metaballPositions[10];
            uniform float metaballRadii[10];

            // SDF for a sphere
            float sphereSDF(vec3 p, float r) {
                return length(p) - r;
            }

            // Smooth minimum function
            float smin(float a, float b, float k) {
                return -log(exp(-k * a) + exp(-k * b)) / k;
            }

            // Combine multiple SDFs
            float sceneSDF(vec3 p) {
                float dist = 1.0;
                for (int i = 0; i < int(metaballCount); ++i) {
                    dist = smin(dist, sphereSDF(p - metaballPositions[i], metaballRadii[i]), 0.2);
                }
                return dist;
            }

            // Ray marching function
            float rayMarch(vec3 origin, vec3 direction) {
                float dist = 0.0;
                for (int i = 0; i < 128; ++i) {
                    vec3 p = origin + direction * dist;
                    float s = sceneSDF(p);
                    if (s < 0.001) {
                        return dist;
                    }
                    dist += s;
                    if (dist > 10.0) {
                        return 10.0;
                    }
                }
                return 10.0;
            }

            // Calculate normal
            vec3 getNormal(vec3 p) {
                float epsilon = 0.001;
                vec3 e = vec3(epsilon, 0.0, 0.0);
                vec3 n = vec3(
                    sceneSDF(p + e.x) - sceneSDF(p - e.x),
                    sceneSDF(p + e.y) - sceneSDF(p - e.y),
                    sceneSDF(p + e.z) - sceneSDF(p - e.z)
                );
                return normalize(n);
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution;
                vec3 rayOrigin = vec3(0.0, 0.0, 5.0);
                vec3 rayDirection = normalize(vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, -1.0));

                float dist = rayMarch(rayOrigin, rayDirection);

                vec3 color;
                if (dist < 10.0) {
                    vec3 hitPoint = rayOrigin + rayDirection * dist;
                    vec3 normal = getNormal(hitPoint);
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float diffuse = max(dot(normal, lightDir), 0.0);

                    // Psychedelic coloring
                    float hue = (sin(time + hitPoint.x * 0.5 + hitPoint.y * 0.3) * 0.5 + 0.5);
                    color = vec3(sin(hue + 2.0/3.0)*0.5 + 0.5, sin(hue)*0.5 + 0.5, sin(hue - 2.0/3.0)*0.5 + 0.5);
                    color *= diffuse * 0.5 + 0.5;
                } else {
                    color = vec3(0.0);
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // --- Compile and Link Shaders ---
        const vertexShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // --- Get Uniform Locations ---
        const timeUniform = gl.getUniformLocation(program, 'time');
        const resolutionUniform = gl.getUniformLocation(program, 'resolution');
        const metaballCountUniform = gl.getUniformLocation(program, 'metaballCount');
        const metaballPositionsUniform = gl.getUniformLocation(program, 'metaballPositions');
        const metaballRadiiUniform = gl.getUniformLocation(program, 'metaballRadii');

        // --- Initialize Metaballs ---
        const numMetaballs = 8;
        const metaballPositions = new Float32Array(numMetaballs * 3);
        const metaballRadii = new Float32Array(numMetaballs);

        for (let i = 0; i < numMetaballs; ++i) {
            metaballPositions[i * 3 + 0] = (Math.random() - 0.5) * 2.0;
            metaballPositions[i * 3 + 1] = (Math.random() - 0.5) * 2.0;
            metaballPositions[i * 3 + 2] = (Math.random() - 0.5) * 2.0;
            metaballRadii[i] = Math.random() * 0.5 + 0.2;
        }

        // --- Render Loop ---
        let startTime = null;
        function render(currentTime) {
            if (!startTime) startTime = currentTime;
            const time = (currentTime - startTime) * 0.001;

            gl.uniform1f(timeUniform, time);
            gl.uniform2f(resolutionUniform, canvas.width, canvas.height);
            gl.uniform1f(metaballCountUniform, numMetaballs);
            gl.uniform3fv(metaballPositionsUniform, metaballPositions);
            gl.uniform1fv(metaballRadiiUniform, metaballRadii);

            // Update metaball positions for animation
            for (let i = 0; i < numMetaballs; ++i) {
                metaballPositions[i * 3 + 0] += Math.sin(time * 0.5 + i * 0.2) * 0.01;
                metaballPositions[i * 3 + 1] += Math.cos(time * 0.7 + i * 0.3) * 0.01;
                metaballPositions[i * 3 + 2] += Math.sin(time * 0.9 + i * 0.1) * 0.01;
            }


            gl.drawArrays(gl.TRIANGLES, 0, 6); // Draw the fullscreen quad

            requestAnimationFrame(render);
        }

        // --- Initial Setup ---
        gl.viewport(0, 0, canvas.width, canvas.height);
        render(0);
    </script>

    <!-- Optional section for notes -->
    <section id="notes">
        <h2>Implementation Notes:</h2>
        <ul>
            <li><b>SDF Combination:</b> Uses a smooth minimum function (`smin`) with a small `k` value (0.2) to blend the sphere SDFs. This creates the smooth merging effect.</li>
            <li><b>Ray Marching:</b> A simple ray marching loop iterates until a surface is hit or a maximum distance is reached.</li>
            <li><b>Normal Calculation:</b>  The normal is approximated using finite differences of the SDF.</li>
            <li><b>Coloring:</b>  Colors are generated using a psychedelic palette based on the hit point's position and time, and modulated by the diffuse lighting.</li>
            <li><b>Animation:</b> Metaball positions are updated each frame using sine and cosine functions to create a swirling, organic motion.</li>
            <li><b>Performance:</b> This is a relatively simple implementation. Optimizations could include reducing the number of ray marching steps, using a more efficient SDF combination function, or implementing early ray termination techniques.</li>
        </ul>
    </section>
</body>
</html>