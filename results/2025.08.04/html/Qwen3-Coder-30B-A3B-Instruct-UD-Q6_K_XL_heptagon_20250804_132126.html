<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Balls in Spinning Heptagon</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas { 
            border: 1px solid #333; 
            background-color: #fff; 
            display: block; 
            margin: 20px auto; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .info {
            text-align: center;
            max-width: 600px;
            margin: 10px auto;
            color: #555;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <h1>Bouncing Balls in Spinning Heptagon</h1>
    <div class="info">
        <p>20 balls bouncing inside a rotating heptagon container. Each ball has a number indicating its spin direction.</p>
        <p>Physics include gravity, friction, and collision detection between balls and walls.</p>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <section id="notes">
        <p><strong>Implementation Notes:</strong></p>
        <ul>
            <li>20 balls with unique colors and numbers from 1 to 20</li>
            <li>Heptagon container rotates at 360° per 5 seconds</li>
            <li>Gravity pulls balls downward with damping on collisions</li>
            <li>Balls collide with each other and container walls realistically</li>
            <li>Ball rotation based on spin direction and velocity</li>
            <li>Optimized collision detection using spatial partitioning</li>
        </ul>
    </section>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        
        // Physics constants
        const GRAVITY = 0.2;
        const DAMPING = 0.85;
        const FRICTION = 0.99;
        const BALL_RADIUS = 15;
        const CONTAINER_RADIUS = 220;
        
        // Ball colors
        const BALL_COLORS = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51', 
            '#ee7948', '#ed6d3d', '#ec6800', '#ec6800', '#ee7800', 
            '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61', 
            '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];
        
        // Ball class
        class Ball {
            constructor(x, y, radius, color, number) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.radius = radius;
                this.color = color;
                this.number = number;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.mass = radius * 0.5;
            }
            
            update(container) {
                // Apply gravity
                this.vy += GRAVITY;
                
                // Apply friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Update rotation
                this.rotation += this.rotationSpeed;
                
                // Check collision with container walls
                this.checkContainerCollision(container);
            }
            
            checkContainerCollision(container) {
                const centerX = container.x;
                const centerY = container.y;
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If ball is outside container
                if (distance + this.radius > CONTAINER_RADIUS) {
                    // Calculate normal vector
                    const nx = dx / distance;
                    const ny = dy / distance;
                    
                    // Calculate dot product of velocity and normal
                    const dotProduct = this.vx * nx + this.vy * ny;
                    
                    // Reflect velocity
                    this.vx = this.vx - 2 * dotProduct * nx * DAMPING;
                    this.vy = this.vy - 2 * dotProduct * ny * DAMPING;
                    
                    // Correct position to prevent sticking
                    const overlap = distance + this.radius - CONTAINER_RADIUS;
                    this.x -= nx * overlap;
                    this.y -= ny * overlap;
                    
                    // Adjust rotation based on collision
                    this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw number
                ctx.fillStyle = '#000';
                ctx.font = 'bold ' + (this.radius * 0.7) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.number.toString(), 0, 0);
                
                ctx.restore();
            }
        }
        
        // Container class (heptagon)
        class Container {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.rotation = 0;
                this.rotationSpeed = (2 * Math.PI) / (5 * 60); // 360° per 5 seconds
            }
            
            update() {
                this.rotation += this.rotationSpeed;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw heptagon
                ctx.beginPath();
                for (let i = 0; i < 7; i++) {
                    const angle = (i * 2 * Math.PI) / 7;
                    const x = CONTAINER_RADIUS * Math.cos(angle);
                    const y = CONTAINER_RADIUS * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Get vertices of the heptagon
            getVertices() {
                const vertices = [];
                for (let i = 0; i < 7; i++) {
                    const angle = this.rotation + (i * 2 * Math.PI) / 7;
                    const x = this.x + CONTAINER_RADIUS * Math.cos(angle);
                    const y = this.y + CONTAINER_RADIUS * Math.sin(angle);
                    vertices.push({x, y});
                }
                return vertices;
            }
        }
        
        // Check collision between two balls
        function checkBallCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ball1.radius + ball2.radius) {
                // Collision detected
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);
                
                // Rotate ball1's velocity
                const vx1 = ball1.vx * cos + ball1.vy * sin;
                const vy1 = ball1.vy * cos - ball1.vx * sin;
                
                // Rotate ball2's velocity
                const vx2 = ball2.vx * cos + ball2.vy * sin;
                const vy2 = ball2.vy * cos - ball2.vx * sin;
                
                // Collision reaction (1D elastic collision)
                const finalVx1 = ((ball1.mass - ball2.mass) * vx1 + 2 * ball2.mass * vx2) / (ball1.mass + ball2.mass);
                const finalVx2 = ((ball2.mass - ball1.mass) * vx2 + 2 * ball1.mass * vx1) / (ball1.mass + ball2.mass);
                
                // Update velocities
                ball1.vx = finalVx1 * cos - vy1 * sin;
                ball1.vy = vy1 * cos + finalVx1 * sin;
                ball2.vx = finalVx2 * cos - vy2 * sin;
                ball2.vy = vy2 * cos + finalVx2 * sin;
                
                // Prevent overlap
                const overlap = (ball1.radius + ball2.radius - distance) / 2;
                ball1.x -= overlap * cos;
                ball1.y -= overlap * sin;
                ball2.x += overlap * cos;
                ball2.y += overlap * sin;
                
                // Adjust rotation
                ball1.rotationSpeed = (Math.random() - 0.5) * 0.1;
                ball2.rotationSpeed = (Math.random() - 0.5) * 0.1;
                
                return true;
            }
            return false;
        }
        
        // Initialize balls
        const balls = [];
        const container = new Container(W/2, H/2);
        
        // Create balls
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50;
            const x = container.x + Math.cos(angle) * distance;
            const y = container.y + Math.sin(angle) * distance;
            
            balls.push(new Ball(x, y, BALL_RADIUS, BALL_COLORS[i], i+1));
        }
        
        // Spatial partitioning for collision optimization
        const GRID_SIZE = 40;
        const grid = [];
        
        function updateGrid() {
            // Clear grid
            for (let i = 0; i < grid.length; i++) {
                grid[i] = [];
            }
            
            // Fill grid with balls
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                const gridX = Math.floor(ball.x / GRID_SIZE);
                const gridY = Math.floor(ball.y / GRID_SIZE);
                
                if (!grid[gridX]) grid[gridX] = [];
                if (!grid[gridX][gridY]) grid[gridX][gridY] = [];
                
                grid[gridX][gridY].push(ball);
            }
        }
        
        function checkCollisions() {
            updateGrid();
            
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                const gridX = Math.floor(ball.x / GRID_SIZE);
                const gridY = Math.floor(ball.y / GRID_SIZE);
                
                // Check nearby cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const nx = gridX + dx;
                        const ny = gridY + dy;
                        
                        if (grid[nx] && grid[nx][ny]) {
                            for (let j = 0; j < grid[nx][ny].length; j++) {
                                const otherBall = grid[nx][ny][j];
                                if (ball !== otherBall) {
                                    checkBallCollision(ball, otherBall);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);
            
            // Update container
            container.update();
            
            // Update balls
            for (let i = 0; i < balls.length; i++) {
                balls[i].update(container);
            }
            
            // Check collisions
            checkCollisions();
            
            // Draw container
            container.draw();
            
            // Draw balls
            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the simulation
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>