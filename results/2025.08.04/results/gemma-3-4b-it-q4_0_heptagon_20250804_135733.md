```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Bouncing Balls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid black;
            background-color: #fff;
            display: block;
            margin: 20px auto;
        }
    </style>
</head>
<body >
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        const numBalls = 20;
        const gravity = 0.5;
        const damping = 0.9;
        const ballRadius = 10; // Adjust for container size
        const heptagonSize = 150; // Adjust for container size
        const heptagonRadius = heptagonSize / 2;
        const spinSpeed = 360 / 5;
        const colors = [
            '#f8b862', '#f6ad49', '#f39800', '#f08300', '#ec6d51', '#ee7948', '#ed6d3d', '#ec6800', '#ec6800',
            '#ee7800', '#eb6238', '#ea5506', '#ea5506', '#eb6101', '#e49e61', '#e45e32', '#e17b34', '#dd7a56', '#db8449', '#d66a35'
        ];

        let balls = [];
        let ballCount = 0;

        function createBall() {
            if (ballCount >= numBalls) return;

            const ball = {
                x: W / 2,
                y: H / 2,
                vx: (Math.random() - 0.5) * 2,
                vy: -5,
                radius: ballRadius,
                mass: ballRadius * ballRadius,
                color: colors[Math.floor(Math.random() * colors.length)],
                spin: Math.random() - 0.5 // initial spin
            };
            balls.push(ball);
            ballCount++;
        }

        function drawHeptagon() {
            ctx.beginPath();
            ctx.moveTo(W / 2 - heptagonRadius, H / 2);
            for (let i = 0; i < 7; i++) {
                const angle = i * (2 * Math.PI / 7);
                const x = W / 2 - heptagonRadius + Math.cos(angle) * heptagonRadius;
                const y = H / 2 - heptagonRadius + Math.sin(angle) * heptagonRadius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = 'black';
            ctx.fill();
        }

        function drawBall(ball) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
            ctx.fillStyle = ball.color;
            ctx.fill();

            // Draw number on ball
            ctx.fillStyle = 'black';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(ball.spin + 1, ball.x, ball.y);
        }

        function updateBall(ball) {
            ball.y += ball.vy;
            ball.vy += gravity;

            // Wall collision detection and response
            if (ball.y + ball.radius > H || ball.y - ball.radius < 0) {
                ball.vy = -ball.vy * damping;
                ball.y = Math.max(ball.radius, Math.min(ball.y, H - ball.radius));
            }

            // Ball-to-ball collision detection and response
            for (let i = 0; i < balls.length; i++) {
                const otherBall = balls[i];
                if (otherBall !== ball) {
                    const distance = Math.sqrt((ball.x - otherBall.x) ** 2 + (ball.y - otherBall.y) ** 2);
                    if (distance <= ball.radius + otherBall.radius) {
                        // Collision detected

                        // Calculate impulse (simplified)
                        const relativeVelocity = (ball.vx - otherBall.vx) * (ball.y - otherBall.y) / distance;
                        const overlap = ball.radius + otherBall.radius - distance;
                        ball.vx -= relativeVelocity * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);
                        otherBall.vx += relativeVelocity * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);

                        ball.vy -= relativeVelocity * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);
                        otherBall.vy += relativeVelocity * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);

                        // Prevent sticking (move balls apart slightly)
                        ball.x = otherBall.x - overlap * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);
                        otherBall.x = ball.x + overlap * (ball.radius + otherBall.radius) / (ball.radius + otherBall.radius);
                    }
                }
            }
        }


        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, W, H);

            // Update balls
            for (let i = 0; i < balls.length; i++) {
                updateBall(balls[i]);
            }

            // Draw heptagon
            drawHeptagon();

            // Draw balls
            for (let i = 0; i < balls.length; i++) {
                drawBall(balls[i]);
            }

            // Update spin
            for (let i = 0; i < balls.length; i++) {
                balls[i].spin += 0.01; // Adjust spin speed
                if (balls[i].spin > 1) balls[i].spin = -1;
            }

            // Rotate heptagon
            ctx.translate(W / 2, H / 2);
            ctx.rotate(spinSpeed * (timestamp - lastTime) / 1000);
            ctx.translate(-W / 2, -H / 2);

            requestAnimationFrame(gameLoop);
            lastTime = timestamp;
        }

        let lastTime = 0;
        createBall();
        createBall();
        createBall(); // create a few balls

        gameLoop(0);

    </script>
</body>
</html>
```

<!-- Benchmark Info -->
<!-- Backend: llamacpp -->
<!-- Model: gemma-3-4b-it-q4_0.gguf -->
<!-- Prompt: heptagon.md -->
<!-- Generation Time: 12.93s -->
<!-- Fallback Used: False -->